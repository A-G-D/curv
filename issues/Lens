Syntax for applying a lens to a value:
    value@lens
with postfix precedence.

Initial support for:
  list@nat
  record@symbol
  collection@lens_list

Are functions also lenses?
 * For now, no. Lists are lenses, but the juxta operator interprets
   a left-hand list argument in a way that conflicts with lens application.
   The algebraic laws are screwed up.
 * If a[i] array index syntax is deprecated and then removed (replaced
   by a.[i]), then lists can become functions in a way compatible with
   lenses, and *then* I can do this.
 * If yes, then 'id' becomes the identity lens.

Full proposal (future design):
  list index    a[i]      a@i
  swizzle       a[[X,Y]]  a@[X,Y]
  array slice   a[i,j]    a@(slice[i,j])
  record index  r.foo     r@#foo
  dict index    d key     d@(index key)
Each of these common operations has two syntaxes: a "conventional" form that
is easy and close to standard notation, and a "general" form using lenses
and the @ operator. The "convention form" syntax has the added property that
sparse multi-D arrays, implemented using dictionaries of index tuples, have
the same indexing syntax as dense multi-D arrays: a[i,j] in both cases.
This allows for some generic programming.

Alt. proposal:
* I want to get rid of the a[i,j] syntax. I've deprecated f(i,j) function
  call syntax, I now write f[i,j], and overloading the juxtaposition
  operator with two different meanings is now a problem.
* a@(slice[i,j]) is verbose.
  Use a.[i,j] as sugar. For now, 'a' is a list, not a general value.
  This syntax is for array indexing, not for general lens application.
* How will sparse arrays work? Implemented on top of dictionaries?
  I want uniform syntax for indexing dense and spare arrays.
  Okay, fine, invent a lens type with those semantics,
  then use a.[i,j] as sugar for that lens.

The syntax `record."foo"` is deprecated.

Consider:
    A[I]
    A@I
If A is a list and I is a lens, and A@I is legal, then A[I] is also legal.
Because I'm sharing code, and A X is defined as A@(slice X) when A is a list.
So that means, A[max] is max(A), and so on.

What do error messages look like? How are they generated by my new code base?
The same lens code can be invoked from A[I] and A@I syntax.

How are type errors reported? Type of the lens doesn't match type of the target.
    ERROR: Lens of type integer doesn't match target (expecting a list)
    Target: aasldkasd
    Lens: 42
    1| x@y
       ^^^

Implementation: Locative, linear logic, precise domains
-------------------------------------------------------
How is this implemented efficiently?
* 'c@lens := val' uses "linear logic" to incrementally update a large
  collection object rather copying it.
* After getting deep into a complex update, if we encounter a domain error,
  then we should panic, because the original collection is gone and we can't
  fail cleanly. This conflicts with the Precise Domains objective. Although
  with the := interface there is no way to trap a failure, so it always panics.
* With the functional version of the interface, you can trap a failure,
  so maybe efficiency is more elusive.

I'll start with the panic-only efficient implementation.
  lens_get(Value val, Value lens) -> Value
  lens_put(Value val, Value lens, Value nu) -> Value
Use std::move to pass the first argument to lens_put.

Locatives
  x := foo
  x@lens := foo
  x.id := foo
  x[i] := foo
nested locatives

Meaning classes:
    Locative : Shared_Base
        // run time; analogues of Operation::eval(Frame&)
        void store(Frame&, Value) const
        Value fetch_copy(Frame& f) const
        Value fetch_move(Frame& f) const

        // analysis/code gen time
        Shared<Locative> analyse_dot(Environ&, Shared<Phrase>, Shared<Op>)
        Shared<Locative> analyse_juxta(Environ&, Shared<Phrase>, Shared<Op>)
        Shared<Locative> analyse_at(Environ&, Shared<Phrase>, Shared<Op>)
