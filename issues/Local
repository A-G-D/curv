Generalized Local Definitions

Any definition can be used as an argument to 'local'.
Syntax like
    local test assert(f x)
    local (x=y, y=x)
works.

TODO:
 * Generalize the definition protocol.
    * Add 'Scope::add_unit(unitary_def) { return 0; }
    * split Definition::analyse() into analyse_recursive and analyse_sequential.
    * define Function_Definition::make_setter() -- sequential case only.
 * fix analyse_stmt()
   To process 'local defn' within 'scope' (a sequential scope), use:
      defn->add_to_scope(scope);
      defn->analyse_sequential(scope);
      op = defn->make_setter(slot_t(-1));

Implementation alternatives:
 1. virtual Shared<const Operation> Definition::add_to_local_scope(Scope&)
    This will require code duplication (relative to add_to_scope()),
    but is more modular than the current code.
 2. Update the definition protocol to support both recursive and sequential
    scopes.

Alternative 2 sounds more elegant. But how does it work?

  Definition::add_to_scope(Scope& scope) calls
    unitnum = scope.add_unit(unitary_defn)
    [slot,Scoped_Variable] = scope.add_binding(symbol, syntax, unitnum)
  Unitary_Definition::analyse(env) calls
    analyse phrases within the definition and store the results internally
  Unitary_Definition::make_setter(module_slot) calls
    construct an Operation from internal state created by analyse().

  Sequential_Scope must implement
    unitnum = scope.add_unit(unitary_defn)
      -- unitnum is always 0
      -- argument is ignored
    [slot, Scoped_Variable] = scope.add_binding(symbol, syntax, unitnum)
      -- this is already implemented correctly by Scope

  This looks trivial:
    Add 'Scope::add_unit(unitary_def) { return 0; }
    To process 'local defn' within 'scope' (a sequential scope), do:
      defn->add_to_scope(scope);
      defn->analyse(scope);
      op = defn->make_setter(slot_t(-1));

  But Function_Definition::analyse won't work, it needs different code for
  the recursive and sequential cases. So split Definition::analyse()
  into ::analyse_recursive and analyse_sequential. Then,
      defn->add_to_scope(scope);
      defn->analyse_sequential(scope);
      op = defn->make_setter(slot_t(-1));
  Plus, define Function_Definition::make_setter() -- sequential case only.

  Why Function_Definition won't work.
    ::analyse() sets shared_nonlocal_ = true in the lambda_phrase_,
      before calling analyse_op() on it.
      It constructs a Lambda_Expr, in which it sets the function name,
      which doesn't currently happen in the case of a local definition.
      (And which shouldn't happen in the final version of Curv.)
      Then it constructs a Lambda, which we don't need,
      and forgets the original Lambda_Expr, which we do need in make_setter().
    ::make_setter() aborts.

  What to do about Function_Definition? It needs to be usable with the
  definition protocol (can't special case it) due to compound definitions.

  ::analyse() stores a Lambda in lambda_, when is that used?
  Referenced by Recursive_Scope::make_function_setter(), which casts a defn
  to a Function_Definition, if unit.is_function() is true (also implemented
  using a cast).

  So define it (used by sequential scopes, but not recursive ones).
    Shared<Operation> Function_Definition::make_setter(slot_t module_slot)
    {
    #if 0 // similar to this:
        auto expr = analyse_op(*func_def->lambda_phrase_, scope, edepth);
        auto pat = make_pattern(*func_def->name_, scope, 0);
        pat->analyse(scope);
        return make<Data_Setter>(stmt, slot_t(-1), pat, expr);
    #endif
      return make<Data_Setter>(
        syntax_, module_slot, pattern, expr);
    }
