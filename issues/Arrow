Arrows are a new primitive data structure.
The arrow `a => b` is a generic ordered pair containing `a` and `b`.
The syntax suggests that this value is some kind of mapping from `a` to `b`.
Arrows are used to construct/deconstruct records and related data,
but could be used in any API where you want to visually indicate a mapping,
or a movement from one value to another.

construction:
    <expression> => <expression>
    <identifier> : <expression>   -- a: 42 is a synonym for #a => 42

patterns:
    <pattern> => <pattern>
    <identifier> : <pattern>

indexing:
    arrow.[head]
    arrow.[tail]
where `head` and `tail` are opaque, abstract values. Or, alternatively:
    arrow.head
    arrow.tail
But note that arrows are disjoint from records, so is dot notation confusing
in the context of POD? It depends on what the final ADT mechanism looks like.
Maybe leave this out of an initial implementation and use pattern matching
for decomposition.

An arrow can be considered to be an ordered pair with special syntax.
The motivation for distinguishing between [a,b] and a=>b is the syntax.
Curv is not just a language for programming computers, it is also a language
for communicating mathematical ideas. The syntax a:b and a=>b can be used
in any API where it clarifies the meaning of data relationships and API calls.

Arrows are useful wherever the arrow syntax makes sense for constructing
data structures out of Plain Old Data.
 * A generic arrow (A=>B) connotes a mapping from the head value A
   to the tail value B.
 * An arrow whose head is a symbol has special syntax,
   and connotes a labelled value.

Curv uses arrows for:
 * constructing records. {a: 1, b: 2} or {#a => 1, #b => 2}
 * deconstructing records. `for (name => val in some_record) ...`
 * later, sparse arrays are {1=>x,2=>y,7=>k}

Could in theory be used to encode Swift style function argument lists, which
have a mix of labeled and unlabeled arguments and are ordered.
    range[1, to: 10]

There's a proposal for adding Python-like ordered dictionaries.
With arrows, I don't need to add special syntax for the constructor:
    dict[key1=>elem1, key2=>elem2]

Maybe use arrows for function types?
    Func(ArgType => ResultType)
Or dictionary types:
    Dict(KeyType => ElemType)

In shape constructors:
 * stroke {d: diameter, from: point1, to: point2}
   stroke d (point1 => point2)
   stroke [size: d, point1 => point2]
 * half_plane [p1, p2]
   half_plane (p1 => p2)

Prior art:
 * Lisp has a primitive _pair_ data type (A . B),
   and this is used to represent a mapping in a property list.
   But pairs are also used to build lists, and arrows do not have this function
   in Curv, where lists are primitive and disjoint from arrows.
 * C++ has std::pair, used to represent an individual mapping in a std::map

Variant Values
--------------
I previously proposed that arrows are used to represent variant values,
the dynamically typed version of Haskell algebraic data types.
  #foo -- variant with just a name, no payload
  foo: a -- variant with a name and payload.
The attraction of this is that it elevates Arrows into a fundamental POD
type, a true peer of symbols. It seems parsimonious and elegant.

Some dynamically typed, pure functional languages have labelled values
as a kind of POD.
 * In Cell, `:foo` is a symbol, `:foo(expr)` is a tagged value.
 * In Pointless, `Foo` is a symbol, `Foo(a,b,c)` a labelled tuple,
   `Foo{a=1,b=2}` a labelled record.
 * Erlang is sort of like this. Record constructor:
   #Name{Field1=Expr1,...,FieldK=ExprK}
I find Cell's data model elegant, and this would be similar.

But in practice the syntax is weird.
I find myself wanting distinct syntax for denoting a record field
vs constructing a labelled value. The former should have loose binding,
the latter should be a primary expression (or term).

In Curv, all other special syntax for POD data are primary expressions.
* The exception is negative numerals, and that actually causes problems
  for function call arguments. Eg, remembering to type `f (-1)` even though
  `f 1` works.
In other languages with tagged values, data constructor expressions are
tightly bound. By contrast, : and => are low precedence operators.

Arrows would be used in the internal representation of picker values
(the #picker field has an algebraic data type).
But I find this syntax weird:
  slider[lo,hi] =
    { call: is_num;
      picker: slider: [lo,hi];    // this looks weird to me (nested arrow)
        // because the outer arrow denotes a record field
        // and the inner arrow constructs POD data (a labelled value)
        // and they have the same syntax.
    };

Do I want to introduce a primary expression for labelled values?
 * `#foo:<primary>` is a <primary>

So variant values have a more uniform looking syntax:
    #foo
    #foo:arg
Eg,
    slider[lo,hi] =
      { call: is_num;
        picker: #slider:[lo,hi];
      };

This new syntax would be specifically used in the case where arrows
are used to represent variant values.

If I'm going to use #variantname in the syntax for monadic variant constructor,
then why not use
    #name => data
So then
    slider[lo,hi] =
      { call: is_num;
        picker: #slider => [lo,hi];
      };
It's an <item>, not a <primary>. And it still seems different from the other
suggested use of arrows, which are mappings from A to B.

If I'm going to use different syntax to encode record fields (a: b)
and variant values (#a:b), then is there a compelling reason to
encode both as arrows? Well, the `a=>b` syntax is used in both cases
to construct or pattern match an arrow when `a` is non-constant.
Note that I'd have to choose a fixed representation
when printing these values in both cases.

I can already use `{a: b}` to encode a variant value with a payload,
and that syntax is already a <primary> expression.

So the question is: what advantage is there for separating records
from variant values?
