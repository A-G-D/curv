# Redesign Shape API

## Transformations

### Scale vs Stretch
Similarity Transformations (including `scale`) preserve the structure of
the distance field.
Deformations (including `stretch`) do not preserve distance field structure.
* distinguish `scale` from `stretch`

### Bend
bend {d,angle:a} shape

### Shear
Is there a generalization of `shear_x` and `shear_xy`? Yes.
Should they be combined into a single generic operation `shear`? Not sure.

A 2D shear is characterized by an invariant line L and a Num shear factor K.
Lines parallel to L are translated proportional to K and their perpendicular
distance from L. Eg, existing `shear_x` fixes L as the X axis.

A 3D shear is characterized by an invariant plane P and a Vec2 shear factor K.
Planes parallel to P are translated proportional to K and their perpendicular
distance from P. Eg, existing `shear_xy` fixes P as the XY plane.

We can generalize `shear_x` and `shear_xy` into `shear2d` and `shear3d`,
by allowing the invariant line/plane to be specified as an optional argument.
We'll restrict the invariant line/plane to pass through the origin. Then,
  shear2d{is_num k, is_vec2 invar = X_axis}
  shear3d{is_vec2 k, invar:(v1,v2)}

I could combine shear2d and shear3d into a single overloaded `shear` function,
but maybe I shouldn't.

Here's another path, which I won't follow:
* shear(kx,ky) or skew(anglex,angley) is commonly used by 2D graphics APIs.
* shear([xy,xz],[yx,yz],[zx,zy]) is the 3D generalization (since a 3D
  transformation matrix has 6 shear parameters). Too many parameters.

### Reflect
reflect axis = with_rotation{from:axis, to:X_axis} reflect_x
where
   reflect_x shape = ...;

with_rotation{from: v1, to: v2} transform shape =
 if (v1 == v2)
   transform shape
 else
   shape >> rotate{from:v1, to:v2} >> transform >> rotate{from:v2, to:v1};

rotate a =
    a >> match [
    {from: (is_vec2 v1), to: (is_vec2 v2)} ->
        ...
    {from: (make_vec3 >> v1), to: (make_vec3 >> v2)} ->
        ...
    ...
    ];

X_axis = [1,0];
Y_axis = [0,1];
Z_axis = [0,0,1];

or use current axis definitions with make_vec2.

### Row
row d shapes
row {d,axis} shapes

## Colour
* sRGB.HWB(hue,whiteness,blackness)
* 3 functions that take 'hue' arguments: sRGB.hue,sRGB.HSV,sRGB.HWB.
  Maybe, provide named hue indexes: red,orange,yellow,...
  These names overlap with the named colours, which exist for ease of use,
  and must not be made complicated. Alternatives:
  * Two naming conventions: red,yellow,... vs h_red,h_yellow,...
    or hues.red, hues.yellow, ...
* web_hue has an argument between 0 and 360
* web_hwb(hue,whiteness,blackness): hue is between 0 and 360.
* add an HTML colour picker to the Colour page.

## Rotate_repeat
Better if the cell to repeat is above the origin.
Consistent with cylinder_transform.
Also, this constructs a shape that is mirror-symmetric about the Y axis,
which is the best axis to choose for human psychology reasons.

## Barr's Bend (local bend)
local_bend{range:[xs,xe], centre|fixed_point: x0, angle}

## Bend
`bend d shape` -- seems like it should have more arguments?

I think this is a good operation, it just needs a more specific name.
It bends a cylinder into a torus, and a rectangular sheet into a cylinder.
It transforms from Cartesian to cylindrical coordinates.

circle_bend d shape
cylindrical_map d shape
  -- since it maps cartesian to cylindrical coordinates,
     and may be related to cylindrical_extrude.
cylinder_transform d shape
cylinder_bend d shape

ShapeJS uses RingWrap(r): Wrap band around a cylinder of given radius r.
The `d` argument of Curv `bend` is implicitly `tau*r` in this API.
(This API avoids a singularity at the origin, since there is a cylinder-shaped
dead space surrounding the origin, and r cannot be 0.)

cylinder_wrap{r, d}

## Convention: bend/wrap/radial-repeat parameters

Here's a consistent convention:
* repeat_radial takes a shape centred on the Y axis, below the X axis,
  and duplicates it N times around a circle. This is the convention needed
  by regular_polygon.
* cylinder_wrap takes a strip centred on the Y axis, below the X axis,
  and wraps it around a cylinder. The two ends meet at the top.
  Same bending direction as local_bend. Same convention as RingWrap.
* local_bend takes a strip parallel to the X axis, and bends it.
  Positive angle means bend upwards (same direction as cylinder_wrap).
  Same convention as las/Mercury's Barr bend.

## Linear Repeat

repeat_x (dx) shape
repeat_xy (dx,dy) shape
repeat_xyz (dx,dy,dz) shape

Need a finite version. In repeat_x, the cell centred at the origin has
ordinal 0, and the general sequence is ...,-3,-2,-1,-,1,2,3,...

repeat_x {size:dx, range:(first,last)} shape
repeat_x {d:dx, range:(first,last)} shape

repeat_xy {d:(dx,dy), range:[(firstx,lastx), (firsty,lasty)]}
repeat_xy {d:(dx,dy), xrange:(firstx,lastx), yrange:(firsty,lasty)}
  -- if you omit xrange or yrange, they default to infinite
repeat_xy {d:(dx,dy), from:(firstx,firsty), to:(lastx,lasty)}

## Axis Parameters.

Should I add optional 'axis' parameters to transformations where it is
appropriate?
* 'rotate' already has an axis parameter. This is due to existing industry
  convention where a 3D rotation may be represented by a quaternion,
  by {axis,angle}, or other ways.
* reflect_x, reflect_y and reflect_z? Or reflect axis shape?
* Replace row_x with row, add optional axis argument. 'row {d,axis} shape'.
* I considered 'along axis transform shape', similar to 'at'.
  Different transformations have different default axes, for good reason,
  so this does not end up being simpler in any way.
* 'with_rotation{from: v1, to: v2} transform shape'
* X_axis, Y_axis, Z_axis are all vec3. This creates a type error when a 2D
  axis is needed. So maybe I accept a vec3 with a 0 Z component as a vec2
  as an axis argument. How?
  * is_axis2 a = is_vec2 a || (is_vec3 a && a[Z]==0);
    Then ignore the Z component of 'a', or use a[[X,Y]], or:
    let axis = make_axis2 a;
  * Implement cast patterns?

reflect axis shape =
   //Huge case analysis to optimize axis values that are aligned with the X, Y
   //or Z axes. Or, rotate the axis onto the X axis, then implement one case,
   //then rotate back. Put the optimizations into rotate or with_rotation.
   with_rotation{from:axis, to:X_axis} reflect_x
where
   reflect_x = ...;
   with_rotation{from: v1, to: v2} transform shape =
     if (v1 == v2)
       transform shape
     else
       shape >> rotate{from:v1, to:v2} >> transform >> rotate{from:v2, to:v1};


## axis-aligned rectangle (bbox2)

A bbox2 is represented as a matrix, ((xmin,ymin),(xmax,ymax)).
The top level elements are referenced using bb[MIN] and bb[MAX].
Maybe use a record instead?
  {min:(xmin,ymin), max:(xmax,ymax)}
Then use bb.min and bb.max.

Maybe support a variant,
  {xmin=-inf,ymin=-inf,zmin=-inf,xmax=inf,ymax=inf,zmax=inf}
which is useful for cropping along specified boundaries using `intersection`.

make_bbox2 is a constructor that accepts either form.
    rect b =
        if (is_vec2 b)
            ...
        else
            let bb = make_bbox2 b;
            in ...;
Or BBox2 if I implement coercions.
    rect = switch [
        (Vec2 b) -> ...;
        (BBox2 b) -> ...;
    ];
    BBox2 = switch [
        b@(Vec2 _, Vec2 _) -> b;
        {xmin=-inf, ymin=-inf, xmax=inf, ymax=inf} -> ((xmin,ymin),(xmax,ymax));
    ];
    Vec2 = switch [
        (Num n) -> (n,n);
        (v@(Num _, Num _)) -> v;
    ];
With these definitions,
    BBox2{} == BBox2(-inf,inf) == BBox2((-inf,-inf),(inf,inf))
and it's necessary for the definition of `rect` to list the Vec2 case first,
otherwise it's matched by BBox2. It's easy to get carried away by too many
default conversions. Let's use the "predicate pattern" design instead.
    rect = switch [
        (Vec2 b) -> ...;
        (BBox2 b) -> ...;
        {Num xmin=-inf, Num ymin=-inf, Num xmax=inf, Num ymax=inf} ->
            rect((xmin,ymin),(xmax,ymax));
    ];

## rect

3 overloadings of rect:
  rect(dx,dy)
  rect{min:(xmin,ymin), max:(xmax,ymax)}
  rect{xmin=-inf,ymin=-inf,zmin=-inf,xmax=inf,ymax=inf,zmax=inf}

Colour Atlas Data Structures
============================
An Intensity is a number between 0 and 1 inclusive.

A Colour comprises red, green and blue Intensities.
* just an RGB triple; that's what colour functions return.

A Colour Map is a function mapping an Intensity onto a Colour.
* just a function value
* {colour_map: f}
* eg, rainbow i = sRGB.HSV(i,1,1);

A 2D or 3D Intensity Field maps a point (x,y) or (x,y,z) to an Intensity.
* Could be a function.
* Could be a variant of Shape: {is_2d,is_3d,intensity}
  This type is viewable as graphics.

A 2D or 3D Colour Field maps a point (x,y) or (x,y,z) to a Colour.
If you compose a Colour Map with an Intensity Field you get a Colour Field.
* Could be a function.
* Could be a subtype of Shape: {is_2d,is_3d,colour}
  This type is viewable as graphics.
