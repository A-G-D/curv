# Redesign Shape Atlas API

## Rotate_repeat
Better if the cell to repeat is above the origin.
Consistent with cylinder_transform.
Also, this constructs a shape that is mirror-symmetric about the Y axis,
which is the best axis to choose for human psychology reasons.

## Taper
taper_xy (kx0, ky0, z0, kx1, ky1, z1) shape
Local 3 dimensional taper along the Z axis, between z==z0 and z==z1. When z<=z0, x and y values are scaled by the factors kx0 and ky0. When z1<=z, x and y values are scaled by the factors kx1 and ky1. When z0<z<z1, x/y values are scaled by factors that are a linear ramp between kx0-kx1/ky0-ky1.

taper_xy ((kx0, ky0, z0), (kx1, ky1, z1))

taper_xy ({xy:(kx0, ky0), z:z0}, {xy:(kx1, ky1), z:z1})

taper[{z: z0, scale_xy: (kx0,ky0)}, {z: z1, scale_xy: (kx1, ky1)}]

taper_xy{from: {z: z0, scale_xy: (kx0,ky0)}, to: {z: z1, scale_xy: (kx1, ky1)}}

taper_xy{range:[z0,z1], scale:[[kx0,ky0],[kx1,ky1]]}
    and maybe add an optional axis:[x,y,z] argument.

taper_x ((kx0, y0), (kx1, y1))
taper_x {range:[y0,y1], scale:[kx0,kx1]}

## Bend
`bend d shape` -- seems like it should have more arguments?

I think this is a good operation, it just needs a more specific name.
It bends a cylinder into a torus, and a rectangular sheet into a cylinder.
It transforms from Cartesian to cylindrical coordinates.

circle_bend d shape
cylindrical_map d shape
  -- since it maps cartesian to cylindrical coordinates,
     and may be related to cylindrical_extrude.
cylinder_transform d shape
cylinder_bend d shape

## Linear Repeat

repeat_x (dx) shape
repeat_xy (dx,dy) shape
repeat_xyz (dx,dy,dz) shape

Need a finite version. In repeat_x, the cell centred at the origin has
ordinal 0, and the general sequence is ...,-3,-2,-1,-,1,2,3,...

repeat_x {size:dx, range:(first,last)} shape
repeat_x {d:dx, range:(first,last)} shape

repeat_xy {d:(dx,dy), range:[(firstx,lastx), (firsty,lasty)]}
repeat_xy {d:(dx,dy), xrange:(firstx,lastx), yrange:(firsty,lasty)}
  -- if you omit xrange or yrange, they default to infinite
repeat_xy {d:(dx,dy), from:(firstx,firsty), to:(lastx,lasty)}

## axis-aligned rectangle (bbox2)

A bbox2 is represented as a matrix, ((xmin,ymin),(xmax,ymax)).
The top level elements are referenced using bb[MIN] and bb[MAX].
Maybe use a record instead?
  {min:(xmin,ymin), max:(xmax,ymax)}
Then use bb.min and bb.max.

Maybe support a variant,
  {xmin=-inf,ymin=-inf,zmin=-inf,xmax=inf,ymax=inf,zmax=inf}
which is useful for cropping along specified boundaries using `intersection`.

make_bbox2 is a constructor that accepts either form.
    rect b =
        if (is_vec2 b)
            ...
        else
            let bb = make_bbox2 b;
            in ...;
Or BBox2 if I implement coercions.
    rect = switch [
        (Vec2 b) -> ...;
        (BBox2 b) -> ...;
    ];
    BBox2 = switch [
        b@(Vec2 _, Vec2 _) -> b;
        {xmin=-inf, ymin=-inf, xmax=inf, ymax=inf} -> ((xmin,ymin),(xmax,ymax));
    ];
    Vec2 = switch [
        (Num n) -> (n,n);
        (v@(Num _, Num _)) -> v;
    ];
With these definitions,
    BBox2{} == BBox2(-inf,inf) == BBox2((-inf,-inf),(inf,inf))
and it's necessary for the definition of `rect` to list the Vec2 case first,
otherwise it's matched by BBox2. It's easy to get carried away by too many
default conversions. Let's use the "predicate pattern" design instead.
    rect = switch [
        (Vec2 b) -> ...;
        (BBox2 b) -> ...;
        {Num xmin=-inf, Num ymin=-inf, Num xmax=inf, Num ymax=inf} ->
            rect((xmin,ymin),(xmax,ymax));
    ];

## rect

3 overloadings of rect:
  rect(dx,dy)
  rect{min:(xmin,ymin), max:(xmax,ymax)}
  rect{xmin=-inf,ymin=-inf,zmin=-inf,xmax=inf,ymax=inf,zmax=inf}

Colour Atlas Data Structures
============================
An Intensity is a number between 0 and 1 inclusive.

A Colour comprises red, green and blue Intensities.
* just an RGB triple; that's what colour functions return.

A Colour Map is a function mapping an Intensity onto a Colour.
* just a function value
* {colour_map: f}
* eg, rainbow i = sHSV(i,1,1);

A 2D or 3D Intensity Field maps a point (x,y) or (x,y,z) to an Intensity.
* Could be a function.
* Could be a variant of Shape: {is_2d,is_3d,intensity}
  This type is viewable as graphics.

A 2D or 3D Colour Field maps a point (x,y) or (x,y,z) to a Colour.
If you compose a Colour Map with an Intensity Field you get a Colour Field.
* Could be a function.
* Could be a subtype of Shape: {is_2d,is_3d,colour}
  This type is viewable as graphics.
