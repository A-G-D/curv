let
assert(is_list 0 == false);
assert(is_list());

assert(bit(false)==0 && bit(true)==1);

assert( dot( [], []) == 0 );
assert( dot( [1,2], [3,4]) == 11 );
assert( dot( [[1,2],[3,4]], [[2,0],[1,2]]) == [[4,4],[10,8]] );
assert( dot( [[1,2,3],[4,5,6]], [9,8,7] ) == [46,118] );
assert( dot( [1,2,3], [[2,1,3],[3,3,2],[4,1,2]] ) == [20,10,13] );
assert(
    dot( [[[1],[2]],[[3],[4]]], [[1,2]] )
    == [[[1,2],[2,4]],[[3,6],[4,8]]]
);

assert(cross([2,3,4],[5,6,7]) == (-3,6,-3));

assert(
  identity 3 ==
  [[1,0,0],
   [0,1,0],
   [0,0,1]]
);

assert(
    (do var a:=1;
        var b:=2;
        var c:= do var x:=10; var y:=20; in [x,y];
     in [a,b,c])
    == [1,2,[10,20]]
);

assert(
    let r = {"x":1,y:2};
    in r.x==1 && r."y"==2
);

assert(
  do var r := {a:1};
  in defined(r.a) && defined(r."a") && !defined(r.b)
);

assert(0..<5 == [0,1,2,3,4]);
assert((1,2,3)==[1,2,3] && (1,)==[1] && ()==[]);

assert(reverse(1,2,3) == [3,2,1] && reverse() == []);
assert(sum(1,2,3)==6 && sum()==0);

assert(
  (do var f(x,y) := x+y; var a := (2,3); in f a)
  == 5
);

assert((1,2,3)[0] == 1);
assert((1,2,3)'[0,2] == [1,3]);

assert(
    do var r := {a:1,b:2};
    in r'"a"==1 && r'["a","b"]==[1,2]
);

assert((sqrt << 4) == 2);
assert((1..10 >> map(x->x^2) >> reverse) == [100,81,64,49,36,25,16,9,4,1]);

assert((let q=1; m={a=q;f x = x + a}; in m.f 3) == 4);

assert(
    let f x = if (x <= 0) 1 else x * f(x-1);
    in f 3 == 6
);

assert( 
    let f =
            let zero = 0;
                m = { f g x = if (x > zero) f g (g x) else x };
            in m.f(a->a-1);
    in f 3.25 == -.75
);
assert(
    let n=4;
        s=sqrt;
    in (let na = (n+5);
            rpr f = f na;
        in rpr s) == 3
);

assert(
    do var a := 1;
       var f x := x + a;
    in f 2 == 3
);

/*
assert(
    do var m := {var a:=1; var f x := x + a};
    in m.f 2 == 3
);
*/

assert(
    (do var a:=1; a:=a+2; in a) == 3
);

assert(
  (do var a := 1;
      if (a > 0)
          a := a + 2
      else
          a := a - 2;
   in a) == 3
);

assert(
  (do var a := 1;
      if (a > 0) (
          a := a + 2
      );
   in a) == 3
);

assert(
  (do var a := 1;
      var b := 2;
      if (a > 0) (
          a := a + 2;
          b := b + 3;
      );
   in a + b) == 8
);

assert(
    let Sum list =
            do  var i := 0;
                var total := 0;
                while (i < count list) (
                    total := total + list[i];
                    i := i + 1;
                );
            in total;
    in Sum(1,2,3) == 6
);

assert(
    is_null null && is_bool false && is_num 42 && is_str "" && is_list ()
    && is_record{a:1} && is_record{a=1} && is_record(cube 1) && !is_record()
    && is_fun(x->x) && is_shape(cube 1)
);

assert(
    transpose([1,1],[2,2]) == [[1,2],[1,2]]
);

assert( asin 1 == 1.5707963267948966 && acos 1 == 0 );

assert( round 0.5 == 0 && round 1.5 == 2 );

assert( count {x:1, y:2} == 2 );

assert( indices(1,2) == [0,1] && fields{a:1} == ["a"] );

assert(
    let a = {x:1, y:2};
    in {...a, x:3} == {x:3, y:2}
);

assert( merge({a:1,z:26},{b:17,a:42}) == {a:42,b:17,z:26} );

assert( {map x = x + 1} 3 == 4 );

assert( strcat("foo","bar",0) == "foobar0" );

assert(
    count "foo" == 3 && count "$$" == 1 && count(to_str "$$") == 4
    && count """" == 1
);

assert( "foo"[0] == "f" && "foobar"'[3,2,4] == "boa" );

assert( [if (true) (;)] == [] );

assert( "$(2+2)" == "4" && "$("foo")" == """foo""" && "${"foo"}" == "foo" );

assert( (let x=1 in x+2) == 3
    && (let x=2; y=3; in x+y) == 5
);
assert( [if (true) (1;2)] == [1,2] );
assert( {if (true) (a:1;b:2)} == {a:1,b:2} );

assert( (x+y where x=1;y=2) == 3 );

// script return value:
in {}
