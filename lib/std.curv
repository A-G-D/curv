/* Curv standard library, automatically loaded at startup. */

// lists
concat(vv) = [for (v=vv) for (i=v) i];
reverse v = v'[len(v)-1..0 step -1];
map(f) list = [for (x=list) f x];
filter(p) list = [for (x=list) if (p x) x];
reduce(first,f) rest =
    if (rest==[]) first else reduce(f(first,rest'0), f) rest'[1..len(rest)-1];

// primitive shapes
circle(r) = shape2d {
    dist p = norm p - r,
    bbox = [[-r,-r],[r,r]]
};
square(sz) = shape2d {
    dist p = max[abs p'0 - sz/2, abs p'1 - sz/2],
    bbox = [[-sz/2,-sz/2], [sz/2,sz/2]],
};

// boolean operations
nothing = shape2d {
    dist p = inf,
    bbox = [[inf,inf],[-inf,-inf]]
};
everything = shape2d {
    dist p = -inf,
    bbox = [[-inf,-inf],[inf,inf]]
};
complement(s) = shape2d {
    dist p = -s.dist p,
    bbox = [[-inf,-inf],[inf,inf]]
};
_union2(s1,s2) = shape2d {
    dist p = min[s1.dist p, s2.dist p],
    bbox = [min[s1.bbox'0, s2.bbox'0], max[s1.bbox'1, s2.bbox'1]]
};
union = reduce(nothing, _union2);
intersection2(s1,s2) = shape2d {
    dist p = max[s1.dist p, s2.dist p],
    bbox = [max[s1.bbox'0, s2.bbox'0], min[s1.bbox'1, s2.bbox'1]]
};
difference(s1,s2) = intersection2(s1, complement s2);

// affine transformations
translate(delta) shape = shape2d {
    dist p = shape.dist(p - delta),
    bbox = [shape.bbox'0+delta, shape.bbox'1+delta]
};
scale(s) shape = shape2d {
    dist p = s * shape.dist(p / s),
    bbox = s * shape.bbox
};
