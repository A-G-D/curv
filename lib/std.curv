// Copyright Doug Moen 2016-2017.
// Distributed under The MIT Licence.
// See accompanying file LICENCE.md or https://opensource.org/licenses/MIT

/* Curv standard library, automatically loaded at startup. */
{

deg = tau/360,
e = 2.71828182845904523536028747135266249775724709369995,
phi = sqrt 5 * .5 + .5,
X = 0,
Y = 1,
Z = 2,
MIN = 0,
MAX = 1,
Xaxis = [1,0,0],
Yaxis = [0,1,0],
Zaxis = [0,0,1],

ceil n = -floor(-n),
trunc n = if (n >= 0) floor(n) else ceil(n),
mod(a,m) = a - m * floor(a/m),
rem(a,m) = a - m * trunc(a/m),
mix(a,b,t) = a*(1-t) + b*t,
clamp(v,lo,hi) = min(max(v,lo),hi),

// lists
concat vv = [for (v=vv) for (i=v) i],
reverse v = v'(len(v)-1..0 by -1),
map f list = [for (x=list) f x],
filter p list = [for (x=list) if (p x) x],
reduce(first,f) rest =
    if (rest==[]) first else reduce(f(first,rest'0), f) << rest'(1..<len(rest)),
sum list = reduce(0, (x,y)->x+y) list,
product list = reduce(1, (x,y)->x*y) list,

// linear algebra
is_vec2 x = is_list x && len x == 2 && is_num(x[0]) && is_num(x[1]),
is_vec3 x = is_list x && len x == 3 && is_num(x[0]) && is_num(x[1]) && is_num(x[2]),
cross(p,q) = [p'Y*q'Z - p'Z-q'Y, p'Z*q'X - p'X*q'Z, p'X*q'Y - p'Y*q'X],
identity(n) = [for(i=1..n) [for(j=1..n) if(i==j) 1 else 0]],
transpose(a) = [for(i=0..<len(a'0)) [for(j=0..<len a) a'j'i]],
normalize v = v / mag v,
// phase angle of a vector, range tau/2 to -tau/2
phase v = atan2(v'Y,v'X),
// convert phase angle to unit vector
cis theta = [cos theta, sin theta],

// circular shapes
circle r = make_shape {
    dist p : mag(p[X,Y]) - r,
    bbox : [[-r,-r,0],[r,r,0]],
    is_2d : true,
},
sphere r = make_shape {
    dist p : mag p - r,
    bbox : [[-r,-r,-r],[r,r,r]],
    is_3d : true,
},
cylinder(r,h) = extrude h (circle r),
// Cone: Z is up, origin is in the middle of the base.
// Euclidean distance field.
// Credit: MERCURY (http://mercury.sexy/hg_sdf)
cone(radius, height) = make_shape {
    dist p : (
        var q := [mag(p[X,Y]), p[Z]];
        var tip := q - [0, height];
        var mantleDir := normalize(height, radius);
        var mantle := dot(tip, mantleDir);
        var d := max(mantle, -q[Y]);
        var projected := dot(tip, [mantleDir[Y], -mantleDir[X]]);

        // distance to tip
        if (q[Y] > height && projected < 0)
            d := max(d, mag(tip));

        // distance to base ring
        if (q[X] > radius && projected > mag(height, radius))
            d := max(d, mag(q - [radius, 0]));
        d
    ),
    bbox : [[-radius,-radius,0],[radius,radius,height]],
    is_3d : true
},
// r1: major radius, from origin to centre of tube.
// r2: minor radius, of the tube.
torus (r1,r2) = perimeter_extrude (circle r1) (circle r2),
// from OpenSCAD
rotate_extrude shape = perimeter_extrude (circle 0) shape,
// A generalized torus. Sweep a 2D shape around the perimeter of another
// 2D shape.
perimeter_extrude perimeter cross_section = make_shape {
    dist p : cross_section.dist( perimeter.dist(p[X],p[Y],0), p[Z], 0 ),
    bbox : [
        [ perimeter.bbox[MIN][X] - cross_section.bbox[MAX][X],
          perimeter.bbox[MIN][Y] - cross_section.bbox[MAX][X],
          cross_section.bbox[MIN][Y] ],
        [ perimeter.bbox[MAX][X] + cross_section.bbox[MAX][X],
          perimeter.bbox[MAX][Y] + cross_section.bbox[MAX][X],
          cross_section.bbox[MAX][Y] ],
    ],
    is_3d : true,
},

// polytopes
square sz = (
  s = if (is_list sz) sz else [sz,sz];
  make_shape {
    dist p : max(abs(p[X,Y]) - s/2),
    //bbox : [-s/2, s/2],
    bbox : [[-s[X]/2,-s[Y]/2,0], [s[X]/2,s[Y]/2,0]],
    is_2d : true,
  }
),
cube sz = (
  s = if (is_list sz) sz else [sz,sz,sz];
  make_shape {
    dist p : max(abs p - s/2),
    bbox : [-s/2, s/2],
    is_3d : true,
  }
),
// rect: an axis aligned rectangle. Argument is a vec2 or a bbox2.
// Mitred distance field.
rect b =
  if (is_vec2 b)
    make_shape {
      dist p : max(abs(p[X,Y]) - b),
      bbox : [[-b[X],-b[Y],0],[b[X],b[Y],0]],
      is_2d : true,
    }
  else (
    xmin = b'0'X;
    ymin = b'0'Y;
    xmax = b'1'X;
    ymax = b'1'Y;
    intersection (
      if (xmin > -inf) make_shape {
        dist p : xmin - p'X,
        bbox : [[xmin, -inf, 0], [inf, inf, 0]],
        is_2d : true,
      },
      if (ymin > -inf) make_shape {
        dist p : ymin - p'Y,
        bbox : [[-inf, ymin, 0], [inf, inf, 0]],
        is_2d : true,
      },
      if (xmax < inf) make_shape {
        dist p : p'X - xmax,
        bbox : [[-inf, -inf, 0], [xmax, inf, 0]],
        is_2d : true,
      },
      if (ymax < inf) make_shape {
        dist p : p'Y - ymax,
        bbox : [[-inf, -inf, 0], [inf, ymax, 0]],
        is_2d : true,
      },
    )
  ),
// Axis aligned rectangle with a Euclidean distance field. Arg is vec2.
rect_eu b = make_shape {
    dist p : (
        var d := abs(p[X,Y]) - b;
        min(max d, 0) + mag(max(d,0))
    ),
    bbox : [[-b[X],-b[Y],0],[b[X],b[Y],0]],
    is_2d : true,
},
// box: an axis aligned cuboid. Argument is a vec3 or a bbox.
// Mitred distance field.
box b =
  if (is_vec3 b)
    make_shape {
      dist p : max(abs p - b),
      bbox : [-b, b],
      is_3d : true,
    }
  else (
    /* Won't compile right now.
    make_shape {
      dist p : max(max(b[MIN]-p), max(p-b[MAX])),
      bbox : b,
      is_3d : true,
    }
    */
    xmin = b'0'X;
    ymin = b'0'Y;
    zmin = b'0'Z;
    xmax = b'1'X;
    ymax = b'1'Y;
    zmax = b'1'Z;
    intersection (
      if (xmin > -inf) make_shape {
          dist p : xmin - p'X,
          bbox : [[xmin, -inf, 0], [inf, inf, 0]],
          is_3d : true,
      },
      if (ymin > -inf) make_shape {
          dist p : ymin - p'Y,
          bbox : [[-inf, ymin, 0], [inf, inf, 0]],
          is_3d : true,
      },
      if (zmin > -inf) make_shape {
          dist p : zmin - p'Z,
          bbox : [[-inf, zmin, 0], [inf, inf, 0]],
          is_3d : true,
      },
      if (xmax < inf) make_shape {
          dist p : p'X - xmax,
          bbox : [[-inf, -inf, 0], [xmax, inf, 0]],
          is_3d : true,
      },
      if (ymax < inf) make_shape {
          dist p : p'Y - ymax,
          bbox : [[-inf, -inf, 0], [inf, ymax, 0]],
          is_3d : true,
      },
      if (zmax < inf) make_shape {
          dist p : p'Z - zmax,
          bbox : [[-inf, -inf, 0], [inf, zmax, 0]],
          is_3d : true,
      },
    )
  ),
// box_eu: an axis aligned cuboid, with Euclidean distance field.
// Argument is a vec3.
box_eu b = make_shape {
    dist p : (
        var d := abs p - b;
        min(max d, 0) + mag(max(d,0))
    ),
    bbox : [-b, b],
    is_3d : true,
},
// 'r' is the radius of a sphere inscribed inside the octahedron.
// Vertexes are aligned with the X,Y,Z axes. Mitred distance field.
octahedron r = (
    v0 = normalize(1,1,1);
    v1 = normalize(-1,1,1);
    v2 = normalize(1,-1,1);
    v3 = normalize(1,1,-1);
    // radius of circumscribed sphere / radius of inscribed sphere
    circumratio = (1/2*sqrt 2) / (1/6*sqrt 6);
    make_shape {
        dist p : (
            max (
                abs(dot(p, v0)),
                abs(dot(p, v1)),
                abs(dot(p, v2)),
                abs(dot(p, v3)),
            ) - r
        ),
        is_3d : true,
        bbox : circumratio * [[-r,-r,-r], [r,r,r]],
        circumratio : circumratio,
    }
),
// 'r' is the radius of a sphere inscribed inside the dodecahedron.
// Mitred distance field. Pointy side down.
dodecahedron r = (
    v0 = normalize(0, phi, 1);
    v1 = normalize(0, -phi, 1);
    v2 = normalize(1, 0, phi);
    v3 = normalize(-1, 0, phi);
    v4 = normalize(phi, 1, 0);
    v5 = normalize(-phi, 1, 0);
    midratio = (.25*(3+sqrt(5))) / (1/20*sqrt(250+110*sqrt(5)));
    circumratio = (.25*(sqrt 3 + sqrt 15)) / (1/20*sqrt(250+110*sqrt(5)));
    make_shape {
        dist p : (
            max (
                abs(dot(p, v0)),
                abs(dot(p, v1)),
                abs(dot(p, v2)),
                abs(dot(p, v3)),
                abs(dot(p, v4)),
                abs(dot(p, v5)),
            ) - r
        ),
        is_3d : true,
        bbox : midratio * [[-r,-r,-r],[r,r,r]],
        circumratio : circumratio,
    }
),
// 'r' is the radius of a sphere inscribed inside the icosahedron.
// Mitred distance field.
icosahedron r = (
    v0 = normalize(1,1,1);
    v1 = normalize(-1,1,1);
    v2 = normalize(1,-1,1);
    v3 = normalize(1,1,-1);
    v4 = normalize(0, +1, phi+1);
    v5 = normalize(0, -1, phi+1);
    v6 = normalize(+phi+1, 0, 1);
    v7 = normalize(-phi-1, 0, 1);
    v8 = normalize(+1, phi+1, 0);
    v9 = normalize(-1, phi+1, 0);
    // radius of midsphere / radius of insphere
    midratio = (phi/2) / (1/12*(3*sqrt(3)+sqrt(15)));
    circumratio = (.25*sqrt(10+2*sqrt 5)) / (1/12*(3*sqrt(3)+sqrt(15)));
    make_shape {
        dist p : (
            max (
                abs(dot(p, v0)),
                abs(dot(p, v1)),
                abs(dot(p, v2)),
                abs(dot(p, v3)),
                abs(dot(p, v4)),
                abs(dot(p, v5)),
                abs(dot(p, v6)),
                abs(dot(p, v7)),
                abs(dot(p, v8)),
                abs(dot(p, v9)),
            ) - r
        ),
        is_3d : true,
        bbox : midratio * [[-r,-r,-r], [r,r,r]],
        circumratio : circumratio,
    }
),
// The size of a regular polytope is specified using an inradius
// (the radius of a sphere inscribed inside the polytope).
// If you want to construct a polytope using a specified circumradius instead,
// then construct it using the circumradius (it will be too big),
// then shrink it to the correct size using `circumscale`.
circumscale shape = scale(1/shape.circumratio) shape,

// boolean shape operations
nothing = make_shape {
    dist p : inf,
    bbox : [[inf,inf,inf],[-inf,-inf,-inf]],
    is_2d : true,
    is_3d : true,
},
everything = make_shape {
    dist p : -inf,
    bbox : [[-inf,-inf,-inf],[inf,inf,inf]],
    is_2d : true,
    is_3d : true,
},
complement s = make_shape {
    dist p : -s.dist p,
    bbox : [[-inf,-inf,-inf],[inf,inf,inf]],
    is_2d : s.is_2d,
    is_3d : s.is_3d,
},
_union2(s1,s2) = make_shape {
    dist p : min(s1.dist p, s2.dist p),
    colour p : (
        var d1 := s1.dist p;
        var d2 := s2.dist p;
        if (d2 <= 0 || d2 <= d1) s2.colour p else s1.colour p
    ),
    bbox : [min(s1.bbox'0, s2.bbox'0), max(s1.bbox'1, s2.bbox'1)],
    is_2d : s1.is_2d && s2.is_2d,
    is_3d : s1.is_3d && s2.is_3d,
},
// When unioning a list of coloured shapes, we paint the shapes from first to
// last order: the last shape is painted on top of its predecessors.
union list = reduce(nothing, _union2) list,
_intersection2(s1,s2) = make_shape {
    dist p : max(s1.dist p, s2.dist p),
    colour : s1.colour,
    bbox : [max(s1.bbox'0, s2.bbox'0), min(s1.bbox'1, s2.bbox'1)],
    is_2d : s1.is_2d && s2.is_2d,
    is_3d : s1.is_3d && s2.is_3d,
},
intersection list = reduce(everything, _intersection2) list,
difference(s1,s2) = _intersection2(s1, complement s2),
symmetric_difference shapes = difference(union shapes, intersection shapes),

// affine transformations
translate _delta shape = (
    delta = if (len _delta == 2) [_delta[X],_delta[Y],0] else _delta;
    if (shape.is_2d) assert(delta[Z] == 0);
    make_shape {
        dist p : shape.dist(p - delta),
        colour p : shape.colour(p - delta),
        bbox : [shape.bbox'0+delta, shape.bbox'1+delta],
        is_2d : shape.is_2d,
        is_3d : shape.is_3d,
    }
),
scale s shape = make_shape {
    dist p : s * shape.dist(p / s),
    colour p : shape.colour(p / s),
    bbox : s * shape.bbox,
    is_2d : shape.is_2d,
    is_3d : shape.is_3d,
},
// rotate angle shape -- 2D rotation around the Z axis
// rotate (angle,axis) shape -- 3D rotation around specified axis
rotate a shape =
  if (is_num a)
    make_shape { // 2D rotation around the Z axis
    dist p : shape.dist(cos(a)*p'X + sin(a)*p'Y, cos(a)*p'Y - sin(a)*p'X, p'Z),
    //dist p : shape.dist(cmul(p, cis(-a))),
    colour p : shape.colour(cos(a)*p'X+sin(a)*p'Y, cos(a)*p'Y-sin(a)*p'X, p'Z),
    bbox : shape.bbox, // TODO: fixme, see below
    is_2d : shape.is_2d,
    is_3d : shape.is_3d,
    }
  else (
    assert(is_list a && len a == 2);
    angle = a[0];
    axis = normalize(a[1]);
    assert(shape.is_3d);
    make_shape {
      dist p : shape.dist <<
        p * cos(angle)
        - cross(axis, p) * sin(angle)
        + axis * dot(axis, p * (1 - cos angle)),
      colour p : shape.colour <<
        p * cos(angle)
        - cross(axis, p) * sin(angle)
        + axis * dot(axis, p * (1 - cos angle)),
      bbox : shape.bbox, // TODO: fixme, see below
      is_3d : true,
    }
  ),
/*
points_box points = [min points, max points],

-- Define a Box2 around all of the given points.
pointsBox :: [ℝ2] -> Box2
pointsBox points =
    let
        (xs, ys) = unzip points
    in
        ((minimum xs, minimum ys), (maximum xs, maximum ys))
getBox2 (Rotate2 θ symbObj) =
    let
        ((x1,y1), (x2,y2)) = getBox2 symbObj
        rotate (x,y) = (cos(θ)*x - sin(θ)*y, sin(θ)*x + cos(θ)*y)
    in
        pointsBox [ rotate (x1, y1)
                  , rotate (x1, y2)
                  , rotate (x2, y1)
                  , rotate (x2, y2)
                  ]
*/

// The slice operators convert a 3D shape to a 2D shape
// by extracting a planar cross section.
slice_xy shape = make_shape {
    dist p : shape.dist(p[X],p[Y],0),
    colour p : shape.colour(p[X],p[Y],0),
    bbox : [[shape.bbox[0][X],shape.bbox[0][Y],0],
            [shape.bbox[1][X],shape.bbox[1][Y],0]],
    is_2d : true,
},
slice_xz shape = make_shape {
    dist p : shape.dist(p[X],0,p[Y]),
    colour p : shape.colour(p[X],0,p[Y]),
    bbox : [[shape.bbox[0][X],shape.bbox[0][Z],0],
            [shape.bbox[1][X],shape.bbox[1][Z],0]],
    is_2d : true,
},
slice_yz shape = make_shape {
    dist p : shape.dist(0,p[X],p[Y]),
    colour p : shape.colour(0,p[X],p[Y]),
    bbox : [[shape.bbox[0][Y],shape.bbox[0][Z],0],
            [shape.bbox[1][Y],shape.bbox[1][Z],0]],
    is_2d : true,
},

// 'extrude' converts a 2D shape to a 3D shape, linearly extruding it along the
// positive and negative Z axis by a distance of 'h'. The result is centered
// on the XY plane with a height of 2*h. Similar to Autocad extrude and
// OpenSCAD linear_extrude.
//
// The standard variant is cheaper, and has a mitred distance field.
// The _eu variant is the same shape with a Euclidean distance field.
extrude h shape = make_shape {
    dist p : max(abs(p[Z]) - h, shape.dist(p[X],p[Y],0)),
    bbox : [ [shape.bbox[0][X],shape.bbox[0][Y],-h],
             [shape.bbox[1][X],shape.bbox[1][Y],+h] ],
    is_3d : true,
},
extrude_eu h shape = make_shape {
    dist p : (
        var dz := abs(p[Z]) - h;
        var dxy := shape.dist(p[X],p[Y],0);
        mag(max([dz,dxy],0)) + min(max(dz,dxy), 0)
    ),
    bbox : [ [shape.bbox[0][X],shape.bbox[0][Y],-h],
             [shape.bbox[1][X],shape.bbox[1][Y],+h] ],
    is_3d : true,
},

// Coloured Shapes
colour rgb shape = make_shape {
    dist : shape.dist,
    colour p : rgb,
    bbox : shape.bbox,
    is_2d : shape.is_2d,
    is_3d : shape.is_3d,
},
colourfield f shape = make_shape {
    dist : shape.dist,
    colour : f,
    bbox : shape.bbox,
    is_2d : shape.is_2d,
    is_3d : shape.is_3d,
},
// Each component of an [h,s,v] triple has range 0...1.
hsv2rgb(c) = (
    var m := abs(mod(c'0 + [1,2/3,1/3], 1) * 6 - 3);
    c'2 * mix(1, clamp(m - 1, 0, 1), c'1)
),
red = [1, 0, 0],
orange = [1, .5, 0],  // aka: mix(red,yellow,.5)
yellow = [1, 1, 0],
green = [0, 1, 0],
cyan = [0, 1, 1],
blue = [0, 0, 1],
magenta = [1, 0, 1],
white = [1, 1, 1],
black = [0, 0, 0],

// Low Level / Debugging
distance_field shape = make_shape {
    dist : everything.dist,
    bbox : everything.bbox,
    colour p : (
        var d := shape.dist p;
        var c := if (d >= 0) ceil(d)-d else floor(d)-d;
        [max(-c,0), 0, max(c,0)]
    ),
    is_2d : true,
},

// Select an isosurface of the shape's distance field.
// r > 0: inflate the shape, blow it up like a balloon.
// r == 0: no effect.
// r < 0: deflate the shape.
//
// If the distance field is Euclidean, then positive r yields
// the Minkowski sum of a sphere of radius r, aka rounded offset (CAD),
// aka dilation (Mathematical Morphology).
//
// If the distance field is mitred, the result is a mitred offset (CAD).
//
// WARNING: Two shapes can have identical boundaries, but different distance
// fields, so this is sensitive to the implementation of the shape.
// Useful for debugging, to visualize a distance field.
isosurface r shape = make_shape {
    dist p : shape.dist p - r,
    colour p : shape.colour p,
    bbox : [shape.bbox[0]-r, shape.bbox[1]+r],
    is_2d : shape.is_2d,
    is_3d : shape.is_3d,
},

}
