/* Curv standard library, automatically loaded at startup. */

deg = tau/360;
e = 2.71828182845904523536028747135266249775724709369995;
X = 0;
Y = 1;
Z = 2;

ceil(n) = -floor(-n);
trunc(n) = if (n >= 0) floor(n) else ceil(n);
mod(a,m) = a - m * floor(a/m);
rem(a,m) = a - m * trunc(a/m);

// lists
concat(vv) = [for (v=vv) for (i=v) i];
reverse v = v'(len(v)-1..0 by -1);
map(f) list = [for (x=list) f x];
filter(p) list = [for (x=list) if (p x) x];
reduce(first,f) rest =
    if (rest==[]) first else reduce(f(first,rest'0), f) rest'(1..<len(rest));
sum = reduce(0, (x,y)->x+y);
product = reduce(1, (x,y)->x*y);

// linear algebra
cross(p,q) = [p'Y*q'Z - p'Z-q'Y, p'Z*q'X - p'X*q'Z, p'X*q'Y - p'Y*q'X];
identity(n) = [for(i=1..n) [for(j=1..n) if(i==j) 1 else 0]];
transpose(a) = [for(i=0..<len a'0) [for(j=0..<len a) a'j'i]];
// Generalized dot product that includes vector dot product and matrix product.
// Same as Mathematica Dot[A,B]. Like APL A+.×B, Python numpy.dot(A,B)
dot(a,b) =
  if (len a > 0 && is_list a'0)
    [for(row=a)dot(row,b)]  // matrix*...
  else
    sum(a*b);               // vector*...

// primitive shapes
circle(r) = shape2d {
    dist p = mag p - r,
    bbox = [[-r,-r],[r,r]]
};
square(sz) =
  letrec (s = if (is_list sz) sz else [sz,sz])
  shape2d {
    dist p = max(abs p - s/2),
    bbox = [-s/2, s/2],
  };
rect(bbox) =
  letrec(xmin = bbox'0'X, ymin = bbox'0'Y,
      xmax = bbox'1'X, ymax = bbox'1'Y)
  intersection [
    if (xmin > -inf) shape2d {
        dist p = xmin - p'X,
        bbox = [[xmin, -inf], [inf, inf]]
    },
    if (ymin > -inf) shape2d {
        dist p = ymin - p'Y,
        bbox = [[-inf, ymin], [inf, inf]]
    },
    if (xmax < inf) shape2d {
        dist p = p'X - xmax,
        bbox = [[-inf, -inf], [xmax, inf]]
    },
    if (ymax < inf) shape2d {
        dist p = p'Y - ymax,
        bbox = [[-inf, -inf], [inf, ymax]]
    },
  ];

// boolean shape operations
nothing = shape2d {
    dist p = inf,
    bbox = [[inf,inf],[-inf,-inf]]
};
everything = shape2d {
    dist p = -inf,
    bbox = [[-inf,-inf],[inf,inf]]
};
complement(s) = shape2d {
    dist p = -s.dist p,
    bbox = [[-inf,-inf],[inf,inf]]
};
_union2(s1,s2) = shape2d {
    dist p = min(s1.dist p, s2.dist p),
    colour p = if (s1.dist p <= 0) s1.colour p else s2.colour p,
    bbox = [min(s1.bbox'0, s2.bbox'0), max(s1.bbox'1, s2.bbox'1)]
};
union = reduce(nothing, _union2);
_intersection2(s1,s2) = shape2d {
    dist p = max(s1.dist p, s2.dist p),
    colour = s1.colour,
    bbox = [max(s1.bbox'0, s2.bbox'0), min(s1.bbox'1, s2.bbox'1)]
};
intersection = reduce(everything, _intersection2);
difference(s1,s2) = _intersection2(s1, complement s2);
symmetric_difference shapes = difference(union shapes, intersection shapes);

// affine transformations
translate(delta) shape = shape2d {
    dist p = shape.dist(p - delta),
    colour p = shape.colour(p - delta),
    bbox = [shape.bbox'0+delta, shape.bbox'1+delta]
};
scale(s) shape = shape2d {
    dist p = s * shape.dist(p / s),
    colour p = shape.colour(p / s),
    bbox = s * shape.bbox
};
rotate(a) shape = shape2d {
    dist p = shape.dist(cos(a)*p'X + sin(a)*p'Y, cos(a)*p'Y - sin(a)*p'X),
    //dist p = shape.dist cmul(p, cis(-a)),
    colour p = shape.colour(cos(a)*p'X + sin(a)*p'Y, cos(a)*p'Y - sin(a)*p'X),
    bbox = shape.bbox // TODO: fixme, see below
};
/*
points_box points = [min points, max points];

-- Define a Box2 around all of the given points.
pointsBox :: [ℝ2] -> Box2
pointsBox points =
    letrec
        (xs, ys) = unzip points
    in
        ((minimum xs, minimum ys), (maximum xs, maximum ys))
getBox2 (Rotate2 θ symbObj) =
    letrec
        ((x1,y1), (x2,y2)) = getBox2 symbObj
        rotate (x,y) = (cos(θ)*x - sin(θ)*y, sin(θ)*x + cos(θ)*y)
    in
        pointsBox [ rotate (x1, y1)
                  , rotate (x1, y2)
                  , rotate (x2, y1)
                  , rotate (x2, y2)
                  ]
*/

// Coloured Shapes
colour(rgb)(shape) = shape2d {
    dist = shape.dist,
    bbox = shape.bbox,
    colour(p) = rgb
};
red = [1, 0, 0];
green = [0, 1, 0];
blue = [0, 0, 1];
yellow = [1, 1, 0];
cyan = [0, 1, 1];
magenta = [1, 0, 1];
white = [1, 1, 1];
black = [0, 0, 0];

// GL Debugging
distance_field(shape) = shape2d {
    dist = everything.dist,
    bbox = everything.bbox,
    colour p =
        let(d = shape.dist p)
        let(c = if (d >= 0) ceil(d)-d else floor(d)-d)
        [max(-c,0), 0, max(c,0)],
};
