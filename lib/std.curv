/* Curv standard library, automatically loaded at startup. */
{

deg = tau/360,
e = 2.71828182845904523536028747135266249775724709369995,
X = 0,
Y = 1,
Z = 2,

ceil n = -floor(-n),
trunc n = if (n >= 0) floor(n) else ceil(n),
mod(a,m) = a - m * floor(a/m),
rem(a,m) = a - m * trunc(a/m),

// lists
concat vv = [for (v=vv) for (i=v) i],
reverse v = v'(len(v)-1..0 by -1),
map f list = [for (x=list) f x],
filter p list = [for (x=list) if (p x) x],
reduce(first,f) rest =
    if (rest==[]) first else reduce(f(first,rest'0), f) << rest'(1..<len(rest)),
sum list = reduce(0, (x,y)->x+y) list,
product list = reduce(1, (x,y)->x*y) list,

// linear algebra
cross(p,q) = [p'Y*q'Z - p'Z-q'Y, p'Z*q'X - p'X*q'Z, p'X*q'Y - p'Y*q'X],
identity(n) = [for(i=1..n) [for(j=1..n) if(i==j) 1 else 0]],
transpose(a) = [for(i=0..<len(a'0)) [for(j=0..<len a) a'j'i]],
// Generalized dot product that includes vector dot product and matrix product.
// Same as Mathematica Dot[A,B]. Like APL A+.×B, Python numpy.dot(A,B)
dot(a,b) =
  if (len a > 0 && is_list(a'0))
    [for(row=a)dot(row,b)]  // matrix*...
  else
    sum(a*b),               // vector*...

// phase angle of a vector, range tau/2 to -tau/2
phase v = atan2(v'Y,v'X),

// convert phase angle to unit vector
cis theta = [cos theta, sin theta],

// primitive shapes
circle r = make_shape {
    dist p : mag(p[X,Y]) - r,
    bbox : [[-r,-r,0],[r,r,0]],
    is_2d : true,
    is_3d : false,
},
sphere r = make_shape {
    dist p : mag p - r,
    bbox : [[-r,-r,-r],[r,r,r]],
    is_2d : false,
    is_3d : true,
},
square sz = (
  s = if (is_list sz) sz else [sz,sz];
  make_shape {
    dist p : max(abs(p[X,Y]) - s/2),
    //bbox : [-s/2, s/2],
    bbox : [[-s[X]/2,-s[Y]/2,0], [s[X]/2,s[Y]/2,0]],
    is_2d : true,
    is_3d : false,
  }
),
cube sz = (
  s = if (is_list sz) sz else [sz,sz,sz];
  make_shape {
    dist p : max(abs p - s/2),
    bbox : [-s/2, s/2],
    is_2d : false,
    is_3d : true,
  }
),
rect bbox = (
  xmin = bbox'0'X;
  ymin = bbox'0'Y;
  xmax = bbox'1'X;
  ymax = bbox'1'Y;
  intersection (
    if (xmin > -inf) make_shape {
        dist p : xmin - p'X,
        bbox : [[xmin, -inf, 0], [inf, inf, 0]],
        is_2d : true,
        is_3d : false,
    },
    if (ymin > -inf) make_shape {
        dist p : ymin - p'Y,
        bbox : [[-inf, ymin, 0], [inf, inf, 0]],
        is_2d : true,
        is_3d : false,
    },
    if (xmax < inf) make_shape {
        dist p : p'X - xmax,
        bbox : [[-inf, -inf, 0], [xmax, inf, 0]],
        is_2d : true,
        is_3d : false,
    },
    if (ymax < inf) make_shape {
        dist p : p'Y - ymax,
        bbox : [[-inf, -inf, 0], [inf, ymax, 0]],
        is_2d : true,
        is_3d : false,
    },
  )
),

// boolean shape operations
nothing = make_shape {
    dist p : inf,
    bbox : [[inf,inf,inf],[-inf,-inf,-inf]],
    is_2d : true,
    is_3d : true,
},
everything = make_shape {
    dist p : -inf,
    bbox : [[-inf,-inf,-inf],[inf,inf,inf]],
    is_2d : true,
    is_3d : true,
},
complement s = make_shape {
    dist p : -s.dist p,
    bbox : [[-inf,-inf,-inf],[inf,inf,inf]],
    is_2d : s.is_2d,
    is_3d : s.is_3d,
},
_union2(s1,s2) = make_shape {
    dist p : min(s1.dist p, s2.dist p),
    colour p : if (s1.dist p <= 0) s1.colour p else s2.colour p,
    bbox : [min(s1.bbox'0, s2.bbox'0), max(s1.bbox'1, s2.bbox'1)],
    is_2d : s1.is_2d && s2.is_2d,
    is_3d : s1.is_3d && s2.is_3d,
},
union list = reduce(nothing, _union2) list,
_intersection2(s1,s2) = make_shape {
    dist p : max(s1.dist p, s2.dist p),
    colour : s1.colour,
    bbox : [max(s1.bbox'0, s2.bbox'0), min(s1.bbox'1, s2.bbox'1)],
    is_2d : s1.is_2d && s2.is_2d,
    is_3d : s1.is_3d && s2.is_3d,
},
intersection list = reduce(everything, _intersection2) list,
difference(s1,s2) = _intersection2(s1, complement s2),
symmetric_difference shapes = difference(union shapes, intersection shapes),

// affine transformations
translate _delta shape = (
    delta = if (len _delta == 2) [_delta[X],_delta[Y],0] else _delta;
    if (shape.is_2d) assert(delta[Z] == 0);
    make_shape {
        dist p : shape.dist(p - delta),
        colour p : shape.colour(p - delta),
        bbox : [shape.bbox'0+delta, shape.bbox'1+delta],
        is_2d : shape.is_2d,
        is_3d : shape.is_3d,
    }
),
scale s shape = make_shape {
    dist p : s * shape.dist(p / s),
    colour p : shape.colour(p / s),
    bbox : s * shape.bbox,
    is_2d : shape.is_2d,
    is_3d : shape.is_3d,
},
rotate a shape = make_shape { // 2D rotation around the Z axis
    dist p : shape.dist(cos(a)*p'X + sin(a)*p'Y, cos(a)*p'Y - sin(a)*p'X, p'Z),
    //dist p : shape.dist(cmul(p, cis(-a))),
    colour p : shape.colour(cos(a)*p'X+sin(a)*p'Y, cos(a)*p'Y-sin(a)*p'X, p'Z),
    bbox : shape.bbox, // TODO: fixme, see below
    is_2d : shape.is_2d,
    is_3d : shape.is_3d,
},
/*
points_box points = [min points, max points],

-- Define a Box2 around all of the given points.
pointsBox :: [ℝ2] -> Box2
pointsBox points =
    let
        (xs, ys) = unzip points
    in
        ((minimum xs, minimum ys), (maximum xs, maximum ys))
getBox2 (Rotate2 θ symbObj) =
    let
        ((x1,y1), (x2,y2)) = getBox2 symbObj
        rotate (x,y) = (cos(θ)*x - sin(θ)*y, sin(θ)*x + cos(θ)*y)
    in
        pointsBox [ rotate (x1, y1)
                  , rotate (x1, y2)
                  , rotate (x2, y1)
                  , rotate (x2, y2)
                  ]
*/

// Coloured Shapes
colour rgb shape = make_shape {
    dist : shape.dist,
    bbox : shape.bbox,
    colour(p) : rgb,
    is_2d : shape.is_2d,
    is_3d : shape.is_3d,
},
red = [1, 0, 0],
green = [0, 1, 0],
blue = [0, 0, 1],
yellow = [1, 1, 0],
cyan = [0, 1, 1],
magenta = [1, 0, 1],
white = [1, 1, 1],
black = [0, 0, 0],

// GL Debugging
distance_field shape = make_shape {
    dist : everything.dist,
    bbox : everything.bbox,
    colour p : (
        var d := shape.dist p;
        var c := if (d >= 0) ceil(d)-d else floor(d)-d;
        [max(-c,0), 0, max(c,0)]
    ),
    is_2d : true,
    is_3d : false,
},

}
