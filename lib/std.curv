/* Curv standard library, automatically loaded at startup. */
{

deg = tau/360,
e = 2.71828182845904523536028747135266249775724709369995,
X = 0,
Y = 1,
Z = 2,
Xaxis = [1,0,0],
Yaxis = [0,1,0],
Zaxis = [0,0,1],

ceil n = -floor(-n),
trunc n = if (n >= 0) floor(n) else ceil(n),
mod(a,m) = a - m * floor(a/m),
rem(a,m) = a - m * trunc(a/m),

// lists
concat vv = [for (v=vv) for (i=v) i],
reverse v = v'(len(v)-1..0 by -1),
map f list = [for (x=list) f x],
filter p list = [for (x=list) if (p x) x],
reduce(first,f) rest =
    if (rest==[]) first else reduce(f(first,rest'0), f) << rest'(1..<len(rest)),
sum list = reduce(0, (x,y)->x+y) list,
product list = reduce(1, (x,y)->x*y) list,

// linear algebra
cross(p,q) = [p'Y*q'Z - p'Z-q'Y, p'Z*q'X - p'X*q'Z, p'X*q'Y - p'Y*q'X],
identity(n) = [for(i=1..n) [for(j=1..n) if(i==j) 1 else 0]],
transpose(a) = [for(i=0..<len(a'0)) [for(j=0..<len a) a'j'i]],
normalize v = v / mag v,

// phase angle of a vector, range tau/2 to -tau/2
phase v = atan2(v'Y,v'X),

// convert phase angle to unit vector
cis theta = [cos theta, sin theta],

// primitive shapes
circle r = make_shape {
    dist p : mag(p[X,Y]) - r,
    bbox : [[-r,-r,0],[r,r,0]],
    is_2d : true,
},
sphere r = make_shape {
    dist p : mag p - r,
    bbox : [[-r,-r,-r],[r,r,r]],
    is_3d : true,
},
square sz = (
  s = if (is_list sz) sz else [sz,sz];
  make_shape {
    dist p : max(abs(p[X,Y]) - s/2),
    //bbox : [-s/2, s/2],
    bbox : [[-s[X]/2,-s[Y]/2,0], [s[X]/2,s[Y]/2,0]],
    is_2d : true,
  }
),
cube sz = (
  s = if (is_list sz) sz else [sz,sz,sz];
  make_shape {
    dist p : max(abs p - s/2),
    bbox : [-s/2, s/2],
    is_3d : true,
  }
),
rect bbox = (
  xmin = bbox'0'X;
  ymin = bbox'0'Y;
  xmax = bbox'1'X;
  ymax = bbox'1'Y;
  intersection (
    if (xmin > -inf) make_shape {
        dist p : xmin - p'X,
        bbox : [[xmin, -inf, 0], [inf, inf, 0]],
        is_2d : true,
    },
    if (ymin > -inf) make_shape {
        dist p : ymin - p'Y,
        bbox : [[-inf, ymin, 0], [inf, inf, 0]],
        is_2d : true,
    },
    if (xmax < inf) make_shape {
        dist p : p'X - xmax,
        bbox : [[-inf, -inf, 0], [xmax, inf, 0]],
        is_2d : true,
    },
    if (ymax < inf) make_shape {
        dist p : p'Y - ymax,
        bbox : [[-inf, -inf, 0], [inf, ymax, 0]],
        is_2d : true,
    },
  )
),
// r1: major radius, from origin to centre of tube.
// r2: minor radius, of the tube.
torus (r1,r2) = make_shape {
    dist p : mag( mag(p[X,Y]) - r1, p[Z]) - r2,
    bbox : [[-r1-r2,-r1-r2,-r2],[r1+r2,r1+r2,r2]],
    is_3d : true,
},

// boolean shape operations
nothing = make_shape {
    dist p : inf,
    bbox : [[inf,inf,inf],[-inf,-inf,-inf]],
    is_2d : true,
    is_3d : true,
},
everything = make_shape {
    dist p : -inf,
    bbox : [[-inf,-inf,-inf],[inf,inf,inf]],
    is_2d : true,
    is_3d : true,
},
complement s = make_shape {
    dist p : -s.dist p,
    bbox : [[-inf,-inf,-inf],[inf,inf,inf]],
    is_2d : s.is_2d,
    is_3d : s.is_3d,
},
_union2(s1,s2) = make_shape {
    dist p : min(s1.dist p, s2.dist p),
    colour p : (
        var d1 := s1.dist p;
        var d2 := s2.dist p;
        if (d2 <= 0 || d2 <= d1) s2.colour p else s1.colour p
    ),
    bbox : [min(s1.bbox'0, s2.bbox'0), max(s1.bbox'1, s2.bbox'1)],
    is_2d : s1.is_2d && s2.is_2d,
    is_3d : s1.is_3d && s2.is_3d,
},
union list = reduce(nothing, _union2) list,
_intersection2(s1,s2) = make_shape {
    dist p : max(s1.dist p, s2.dist p),
    colour : s1.colour,
    bbox : [max(s1.bbox'0, s2.bbox'0), min(s1.bbox'1, s2.bbox'1)],
    is_2d : s1.is_2d && s2.is_2d,
    is_3d : s1.is_3d && s2.is_3d,
},
intersection list = reduce(everything, _intersection2) list,
difference(s1,s2) = _intersection2(s1, complement s2),
symmetric_difference shapes = difference(union shapes, intersection shapes),

// affine transformations
translate _delta shape = (
    delta = if (len _delta == 2) [_delta[X],_delta[Y],0] else _delta;
    if (shape.is_2d) assert(delta[Z] == 0);
    make_shape {
        dist p : shape.dist(p - delta),
        colour p : shape.colour(p - delta),
        bbox : [shape.bbox'0+delta, shape.bbox'1+delta],
        is_2d : shape.is_2d,
        is_3d : shape.is_3d,
    }
),
scale s shape = make_shape {
    dist p : s * shape.dist(p / s),
    colour p : shape.colour(p / s),
    bbox : s * shape.bbox,
    is_2d : shape.is_2d,
    is_3d : shape.is_3d,
},
// rotate angle shape -- 2D rotation around the Z axis
// rotate (angle,axis) shape -- 3D rotation around specified axis
rotate a shape =
  if (is_num a)
    make_shape { // 2D rotation around the Z axis
    dist p : shape.dist(cos(a)*p'X + sin(a)*p'Y, cos(a)*p'Y - sin(a)*p'X, p'Z),
    //dist p : shape.dist(cmul(p, cis(-a))),
    colour p : shape.colour(cos(a)*p'X+sin(a)*p'Y, cos(a)*p'Y-sin(a)*p'X, p'Z),
    bbox : shape.bbox, // TODO: fixme, see below
    is_2d : shape.is_2d,
    is_3d : shape.is_3d,
    }
  else (
    assert(is_list a && len a == 2);
    angle = a[0];
    axis = normalize(a[1]);
    assert(shape.is_3d);
    make_shape {
      dist p : shape.dist <<
        p * cos(angle)
        - cross(axis, p) * sin(angle)
        + axis * dot(axis, p * (1 - cos angle)),
      colour p : shape.colour <<
        p * cos(angle)
        - cross(axis, p) * sin(angle)
        + axis * dot(axis, p * (1 - cos angle)),
      bbox : shape.bbox, // TODO: fixme, see below
      is_3d : true,
    }
  ),
/*
points_box points = [min points, max points],

-- Define a Box2 around all of the given points.
pointsBox :: [ℝ2] -> Box2
pointsBox points =
    let
        (xs, ys) = unzip points
    in
        ((minimum xs, minimum ys), (maximum xs, maximum ys))
getBox2 (Rotate2 θ symbObj) =
    let
        ((x1,y1), (x2,y2)) = getBox2 symbObj
        rotate (x,y) = (cos(θ)*x - sin(θ)*y, sin(θ)*x + cos(θ)*y)
    in
        pointsBox [ rotate (x1, y1)
                  , rotate (x1, y2)
                  , rotate (x2, y1)
                  , rotate (x2, y2)
                  ]
*/

// The slice operators convert a 3D shape to a 2D shape
// by extracting a planar cross section.
slice_xy shape = make_shape {
    dist p : shape.dist(p[X],p[Y],0),
    colour p : shape.colour(p[X],p[Y],0),
    bbox : [[shape.bbox[0][X],shape.bbox[0][Y],0],
            [shape.bbox[1][X],shape.bbox[1][Y],0]],
    is_2d : true,
},
slice_xz shape = make_shape {
    dist p : shape.dist(p[X],0,p[Y]),
    colour p : shape.colour(p[X],0,p[Y]),
    bbox : [[shape.bbox[0][X],shape.bbox[0][Z],0],
            [shape.bbox[1][X],shape.bbox[1][Z],0]],
    is_2d : true,
},
slice_yz shape = make_shape {
    dist p : shape.dist(0,p[X],p[Y]),
    colour p : shape.colour(0,p[X],p[Y]),
    bbox : [[shape.bbox[0][Y],shape.bbox[0][Z],0],
            [shape.bbox[1][Y],shape.bbox[1][Z],0]],
    is_2d : true,
},

// 'extrude' converts a 2D shape to a 3D shape, linearly extruding it along the
// positive and negative Z axis by a distance of 'h'. The result is centered
// on the XY plane with a height of 2*h. Similar to Autocad extrude and
// OpenSCAD linear_extrude.
//
// The standard variant is cheaper, and has a mitred distance field.
// The _eu variant is the same shape with a Euclidean distance field.
extrude h shape = make_shape {
    dist p : max(abs(p[Z]) - h, shape.dist(p[X],p[Y],0)),
    bbox : [ [shape.bbox[0][X],shape.bbox[0][Y],-h],
             [shape.bbox[1][X],shape.bbox[1][Y],+h] ],
    is_3d : true,
},
extrude_eu h shape = make_shape {
    dist p : (
        var dz := abs(p[Z]) - h;
        var dxy := shape.dist(p[X],p[Y],0);
        mag(max([dz,dxy],0)) + min(max(dz,dxy), 0)
    ),
    bbox : [ [shape.bbox[0][X],shape.bbox[0][Y],-h],
             [shape.bbox[1][X],shape.bbox[1][Y],+h] ],
    is_3d : true,
},

// Coloured Shapes
colour rgb shape = make_shape {
    dist : shape.dist,
    bbox : shape.bbox,
    colour(p) : rgb,
    is_2d : shape.is_2d,
    is_3d : shape.is_3d,
},
red = [1, 0, 0],
green = [0, 1, 0],
blue = [0, 0, 1],
yellow = [1, 1, 0],
cyan = [0, 1, 1],
magenta = [1, 0, 1],
white = [1, 1, 1],
black = [0, 0, 0],

// GL Debugging
distance_field shape = make_shape {
    dist : everything.dist,
    bbox : everything.bbox,
    colour p : (
        var d := shape.dist p;
        var c := if (d >= 0) ceil(d)-d else floor(d)-d;
        [max(-c,0), 0, max(c,0)]
    ),
    is_2d : true,
},

}
