/* Curv standard library, automatically loaded at startup. */

deg = tau/360;
e = 2.71828182845904523536028747135266249775724709369995;
X = 0;
Y = 1;
Z = 2;
mod(a,m) = a - m * floor(a/m);

// lists
concat(vv) = [for (v=vv) for (i=v) i];
reverse v = v'[len(v)-1..0 step -1];
map(f) list = [for (x=list) f x];
filter(p) list = [for (x=list) if (p x) x];
reduce(first,f) rest =
    if (rest==[]) first else reduce(f(first,rest'0), f) rest'[1..len(rest)-1];
sum = reduce(0, (x,y)->x+y);
product = reduce(1, (x,y)->x*y);

// linear algebra
cross(p,q) = [p'Y*q'Z - p'Z-q'Y, p'Z*q'X - p'X*q'Z, p'X*q'Y - p'Y*q'X];
identity(n) = [for(i=[1..n]) [for(j=[1..n]) if(i==j) 1 else 0]];
transpose(a) = [for(i=[0..len a'0 - 1]) [for(j=[0..len a - 1]) a'j'i]];
// Generalized dot product that includes vector dot product and matrix product.
// Same as Mathematica Dot[A,B]. Like APL A+.×B, Python numpy.dot(A,B)
dot(a,b) =
  if (len a > 0 && is_list a'0)
    [for(row=a)dot(row,b)]  // matrix*...
  else
    sum(a*b);               // vector*...

// primitive shapes
circle(r) = shape2d {
    dist p = norm p - r,
    bbox = [[-r,-r],[r,r]]
};
square(sz) =
  let (s = if (is_list sz) sz else [sz,sz])
  shape2d {
    dist p = max(abs p - s/2),
    bbox = [-s/2, s/2],
  };

// boolean shape operations
nothing = shape2d {
    dist p = inf,
    bbox = [[inf,inf],[-inf,-inf]]
};
everything = shape2d {
    dist p = -inf,
    bbox = [[-inf,-inf],[inf,inf]]
};
complement(s) = shape2d {
    dist p = -s.dist p,
    bbox = [[-inf,-inf],[inf,inf]]
};
_union2(s1,s2) = shape2d {
    dist p = min[s1.dist p, s2.dist p],
    bbox = [min[s1.bbox'0, s2.bbox'0], max[s1.bbox'1, s2.bbox'1]]
};
union = reduce(nothing, _union2);
_intersection2(s1,s2) = shape2d {
    dist p = max[s1.dist p, s2.dist p],
    bbox = [max[s1.bbox'0, s2.bbox'0], min[s1.bbox'1, s2.bbox'1]]
};
intersection = reduce(everything, _intersection2);
difference(s1,s2) = _intersection2(s1, complement s2);
symmetric_difference shapes = difference(union shapes, intersection shapes);

// affine transformations
translate(delta) shape = shape2d {
    dist p = shape.dist(p - delta),
    bbox = [shape.bbox'0+delta, shape.bbox'1+delta]
};
scale(s) shape = shape2d {
    dist p = s * shape.dist(p / s),
    bbox = s * shape.bbox
};
rotate(a) shape = shape2d {
    dist p = shape.dist[cos(a)*p'X + sin(a)*p'Y, cos(a)*p'Y - sin(a)*p'X],
    bbox = shape.bbox // TODO: fixme, see below
};
/*
points_box points = [min points, max points];

-- Define a Box2 around all of the given points.
pointsBox :: [ℝ2] -> Box2
pointsBox points =
    let
        (xs, ys) = unzip points
    in
        ((minimum xs, minimum ys), (maximum xs, maximum ys))
getBox2 (Rotate2 θ symbObj) =
    let
        ((x1,y1), (x2,y2)) = getBox2 symbObj
        rotate (x,y) = (cos(θ)*x - sin(θ)*y, sin(θ)*x + cos(θ)*y)
    in
        pointsBox [ rotate (x1, y1)
                  , rotate (x1, y2)
                  , rotate (x2, y1)
                  , rotate (x2, y2)
                  ]
*/
