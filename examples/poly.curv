// TODO: Maybe the 'prime slice' in rep_rotate is above the X axis, centred
// on the Y axis. More convenient to set up the shape argument.
// Also, you can compute a better bbox.
// For regular_polygon, I'll use a tau/2 rotation on the result.
// TODO: Bounding box. Compute it in rep_rotate from ymax of bbox.
// TODO: half plane API.
// * half_plane(x) -- vertical edge sweeps along X axis from x to inf.
//   Rotate the result as needed. rpoly uses: rotate(-tau/4) half_plane(-1)
// * plane_segment{xmin:,ymin:,xmax:,ymax:}. rpoly uses plane_segment{ymax:1}.
//   Has a better bounding box than a rotated half_plane.
//   Also: crop(c)shape = intersection(shape, plane_segment c);

// NOTE: could optimize by checking for xmin==-xmax & using abs(p'X).
plane_segment limits = (
    xmin = if (defined(limits.xmin)) limits.xmin else -inf;
    xmax = if (defined(limits.xmax)) limits.xmax else inf;
    ymin = if (defined(limits.ymin)) limits.ymin else -inf;
    ymax = if (defined(limits.ymax)) limits.ymax else inf;
    intersection (
        if (xmin > -inf) make_shape {
            dist p : xmin - p'X,
            bbox : [[xmin, -inf, 0], [inf, inf, 0]],
            is_2d : true,
            is_3d : false,
        },
        if (ymin > -inf) make_shape {
            dist p : ymin - p'Y,
            bbox : [[-inf, ymin, 0], [inf, inf, 0]],
            is_2d : true,
            is_3d : false,
        },
        if (xmax < inf) make_shape {
            dist p : p'X - xmax,
            bbox : [[-inf, -inf, 0], [xmax, inf, 0]],
            is_2d : true,
            is_3d : false,
        },
        if (ymax < inf) make_shape {
            dist p : p'Y - ymax,
            bbox : [[-inf, -inf, 0], [inf, ymax, 0]],
            is_2d : true,
            is_3d : false,
        },
    )
);

//union(colour(red) << circle(1), plane_segment{ymax:2});
//distance_field plane_segment{xmin:-1,xmax:1,ymin:-2,ymax:2};

rep_rotate n shape = (
    assert(shape.is_2d);
    na = tau/4 - tau/(n*2);
    rpr f p = (
        var pa := phase p;
        var mpa := mod(pa - na, tau/n) + na;
        var rota := -(pa - mpa);
        var rp := cmul(p, cis rota);
        f rp
    );
    make_shape {
        dist : rpr(shape.dist),
        colour : rpr(shape.colour),
        bbox : everything.bbox,
        is_2d : true,
        is_3d : false,
    }
);

regular_polygon(n) = rotate(tau/2) << rep_rotate(n) << plane_segment{ymax:1};

//rep_rotate(5) << plane_segment{ymax:1};
//regular_polygon(5);

old_rep_rotate(n) shape = make_shape {
    dist p : (
        var ph := phase(p);
        var mph := mod(ph, tau/n);
        var rotangle := -(ph - mph);
        var rp := cmul(p, cis(rotangle));
        shape.dist rp
    ),
    bbox : everything.bbox,
};
// Partition 2-space into n pie slices, radiating from origin.
// rotate p onto the corresponding point in the 'prime' pie slice
//   theta = atan2(p'Y, p'X); -- or, theta = phase(p);
//   theta_prime = mod(theta, tau/n);
// rotate p through the angle -(theta - theta_prime)
//   rotate_by = -(theta - theta_prime);
// maybe construct a rotation matrix, that should be fast in GLSL.
//   sin_r = sin(rotate_by);
//   cos_r = cos(rotate_by);
//   new_p = [p'X*cos_r - p'Y*sin_r, p'Y*cos_r + p'X*sin_r];
// or
//   v = cis(rotate_by);
//   new_p = cmul(p, v);

// phase angle of a vector, range tau/2 to -tau/2
phase v = atan2(v'Y,v'X);

// convert phase angle to unit vector
cis(theta) = [cos theta, sin theta];

mag(v) = sum(v^2);

// complex numbers: [RE,IM]
RE=0;
IM=1;
cmul(z,w) = [z'RE*w'RE - z'IM*w'IM, z'IM*w'RE + z'RE*w'IM];

//old_rep_rotate(5) translate(1,1) circle(1);

half_plane(v) = (
    m = mag v;
    ph = phase v;
    rotate(ph) << make_shape {
        dist p : m - p'X,
        bbox : everything.bbox,
        is_2d : true,
        is_3d : false,
    }
);

rpoly n = (
    a = tau/(n*2);
    rotate(a-tau/4) << old_rep_rotate n << complement << half_plane(cis a)
);

rp n = (
    c = sqrt(1/(1 - sin(tau/(2*n))));
    union(
        colour(red) << circle(.1),
        regular_polygon(n),
        colour(red) << plane_segment{xmax:-c,xmin:-c-.2},
        colour(red) << plane_segment{xmin:c,xmax:c+.2},
        //translate(.7,0) << colour(red) << circle(.1),
    )
);

union (
  rp 3,
  /*
  translate(3,0) << rp 4,
  translate(6,0) << rp 5,
   */
/*
  translate(0,4) << rotate(-tau/4) << rp 3,
  translate(3,4) << rotate(-tau/8) << rp 4,
  translate(6,4) << rotate(-tau/16) << rp 5,

  translate(0,8) << rotate(-tau/12) << rp 3,
  translate(3,8) << rotate(-tau/8) << rp 4,
  translate(6,8) << rotate(-(tau/4 - tau/10)) << rp 5,
 */
)
//complement << half_plane << cis(tau/10)
