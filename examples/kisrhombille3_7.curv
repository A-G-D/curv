size = 100; // of main disk
fn  = 64;  // for the arcs
//depth = 3;
depth = 1;

// background disk
//translate([0,0,-5])color("white") circle(size);

// kisrhombille3_7 is drawn in a unit disk
scale(size) kisrhombille3_7(depth, 0.015);

color(c) shape = shape;

kisrhombille3_7(n,t) =
    let (r = 0.497, // this is a magic number
         q = [for(i=[0..6]) r*[cos(i*tau/7),sin(i*tau/7)] ])
    union[
        //color("magenta")
        for (i=[0..6]) (
            hyperSegment([0,0], q'i, t),
            hyperSegment(q'i, q'(mod(i+1,7)), t),
            hyperSegment(q'i, q'(mod(i+2,7)), t),
        ),
        for(i=[0..6]) 
            recur_kisrhombille3_7(q'i, q'(mod(i+1,7)), n, t)
    ];

recur_kisrhombille3_7(q1, q2, n, t) =
    let (
        p  = hyperRotation(q1,q2,tau/7),
        p1 = hyperRotation(q1,q2,2*tau/7),
        p2 = hyperRotation(q1,q2,3*tau/7),
        q  = hyperRotation(q1,p ,tau/7),
    )
    union [
      //color("red") {
          hyperSegment(p ,q1,t*0.7),
          hyperSegment(p ,q2,t*0.7),
          hyperSegment(p ,p1,t*0.7),
          hyperSegment(p2,p1,t*0.7),
          hyperSegment(p1,q2,t*0.7),
          hyperSegment(p2,q2,t*0.7),
          hyperSegment(p ,q ,t*0.7),
      //}
      //color("blue") {
          hyperSegment(p , hyperReflection(p,q1,q2),t*0.7),
          hyperSegment(p1, hyperReflection(p1,q2,p2),t*0.7),
      //}
      //color("green") {
          hyperSegment(p , p2,t*0.7),
          hyperSegment(q2, q ,t*0.7),
          hyperSegment(q1, p1,t*0.7),
      //}
      if(n>1) (
          recur_kisrhombille3_7(p, p1 , n-1, t*0.7),
          recur_kisrhombille3_7(p1, p2, n-1, t*0.7),
          recur_kisrhombille3_7(q , p , n-1, t*0.7),
      )
    ];

//
//  Hyperbolic geometry functions and modules
//  All points are supposed to be in a unit disk 

// Hyperbolic segment joining p and q
hyperSegment(p,q, t /*=0.05*/) =
    let (
        c = center(p,q),
    )
    union [
        if(c!=null) (
            let (
                R = radius(p,q),
                a01 = atan2((p-c)'1, (p-c)'0),
                a02 = atan2((q-c)'1, (q-c)'0),
                a1 = min[a01,a02],
                a2=max[a01,a02],
                a3 = if (a2-a1>tau/2) a1+tau else a1,
                a4 = a2,
            )
            polyline([for(a=[a3..a4 step (a4-a3)/fn]) R*[cos(a), sin(a)]+c ],t)
        ) else
            polyline([p,q],t)
    ];

hyperLine(p,q, t /*=0.05*/) =
    let (
        s = idealPoints(p,q),
    )
    union [
        if (s!=null)
            hyperSegment(s'0,s'1,t)
        else if (norm(p-q)>1e-6)
            polyline([unit(p-q),unit(q-p)],t)
    ];

// Hyperbolic lines in the unit disk -> Euclidean circles
center(p,q) = 
    if (abs dot(p, [(p-q)'Y, -(p-q)'X]) < 1e-6)
        null // p, q and [0,0] are colinear
    else
        let( u = (dot(p,q)-1)/( 2*dot(p,[(p-q)'Y, -(p-q)'X]) ) )
        (p+q)/2 - u*[(p-q)'Y, -(p-q)'X];

radius(p,q) = norm(center(p, q)-p);

// return the ideal points of a line passing thru p with direction d
hyperLineByDirection(p,d) =
    if (norm(p) < 1e-6)
        (if (norm(d)>1e-6) [unit(d),-unit(d)] else null)
    else
        let( dc = [-d'Y, d'X] )
        if (abs dot(p,dc) < 1e-6)
            [unit(d),-unit(d)]
        else
            let( c  = p + dc*(1 - dot(p,p))/(2*dot(p,dc)) )
            unitCircleInters(c,norm(c-p));

hyperLineDirectionAt(p,q) = /* vec2 */
    let( c = center(p,q) )
    if (c==null)
        (if (norm(p-q)>1e-6) p-q else null)
    else
        [ (p-c)'Y, -(p-c)'X ];

// the extreme points of a hyperline thru p,q
// the result [a,b] is such that the hyperline thru p,q pass by the points
// in the order a,p,q,b
idealPoints(p,q) =
    let( c = center(p,q) )
    if (c == null)
        if (norm(p-q) > 1e-6)
            [ unit(p-q), -unit(p-q)]
        else
            null
    else
        let( ip = unitCircleInters(c,norm(c-p)) )
        if (dot(ip'1-ip'0, p-q) < 0)
            ip
        else
            [ip'1, ip'0] ;
    
// Hyperbolic metric in the unit disk
// It may return an infinity value
hyperDistance(p,q) =
    let( id = idealPoints(p,q) )
    if (norm(p-id'0)<1e-12 || norm(id'1-q)<1e-12)
        inf
    else
        log(norm(q-id'0)*norm(id'1-p)/norm(p-id'0)/norm(id'1-q));

// Hyperbolic transforms

// translation of x by dx
hyperTranslation(x, dx) =
    let( d = 1 + 2*dx*x + dx*dx*x*x )
    if (abs(d) < 1e-6)
        null
    else
        ((1 + dx*x + x*x)*dx + (1 - dx*dx)*x)/d;

hyperReflection(x, p, q) =
    let( c  = center(p,q)) // Euclidean circle of 
                           // hyperline thru p,q
    if (c == null)
        null
    else
        let( r  = radius(p,q),
             cx = x-c,     // dir of the reflected point
             s  = (r/norm(cx))^2 )
        (c + s*cx);

hyperRotation(x,c,a) =
    if (norm(x-c) < 1e-6)
        x
    else
        let( cc = center(x,c),
             d0 = hyperLineDirectionAt(c,x), /* vec2 */
             cs = cos(a/2),
             sn = sin(a/2),
             rt = [[cs,sn],[-sn,cs]], /* mat22 */
             d1 = dot(d0,rt),
             rl = hyperLineByDirection(c,d1))
        hyperReflection(x,rl'0,rl'1);

//    
// Euclidean geometry functions
//

// intersection points between unit circle 
// and the circle [c(enter),r(adius)]
unitCircleInters(c,r) =
    if (norm(c)<1e-6 || norm(c)-abs(r) > 1)
        []
    else
        let( x  = -(r*r - dot(c,c) -1)/norm(c)/2,
             y  = sqrt(1 - x*x) )
        dot([[x,y],[x,-y]], [[c'X,c'Y],[-c'Y,c'X]]) / norm(c);

unit(v) = v/norm(v);

// Drawing module

polyline(p, t/*=1*/) = union [
    for(i=[0..len(p)-2]) (
        let (v = p'(i+1)-p'i)
        let (h = norm(v))
        if( h > 1e-12)
            translate(p'i)
                rotate(atan2(v'Y,v'X)) 
                    translate[-t/2,-t/2] square[h+t,t]
    )
];
