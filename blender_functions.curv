//
// Blender functions ported from http://mercury.sexy/hg_sdf/

// Common function which defines union, difference and intersction
let 
make_blend config args = {
    union (s1,s2) =
        make_shape {
            dist p =
                let a = s1.dist p;
                    b = s2.dist p;
                in bmin(a,b);
            colour p =
                let d1 = s1.dist p;
                    d2 = s2.dist p;
                in if (d2 <= 0 || d2 <= d1) s2.colour p else s1.colour p;
            bbox = [ min(s1.bbox[MIN], s2.bbox[MIN]),
                     max(s1.bbox[MAX], s2.bbox[MAX]) ];
            is_2d = s1.is_2d && s2.is_2d;
            is_3d = s1.is_3d && s2.is_3d;
        };

    intersection (s1,s2) =
        make_shape {
            dist p =
                let a = s1.dist p;
                    b = s2.dist p;
                in bmax(a,b);
            colour = s1.colour;
            bbox = [ max(s1.bbox[MIN], s2.bbox[MIN]),
                     min(s1.bbox[MAX], s2.bbox[MAX]) ];
            is_2d = s1.is_2d && s2.is_2d;
            is_3d = s1.is_3d && s2.is_3d;
        };

    difference (s1,s2) = intersection (s1, complement s2);

    bmin(a,b) = config.fmin(a, b, args);
    bmax(a,b) = -config.fmin(-a, -b, args);
};

////////////////////////////
// Smooth
////////////////////////////


smooth = make_blend {
    fmin (a, b, r) =
	let
	h = clamp( 0.5+0.5*(b-a)/r, 0, 1 );
        in lerp( b, a, h ) - r*h*(1.0-h);

};


////////////////////////////
// Chamfer
////////////////////////////

// fOpUnionChamfer
// fOpIntersectionChamfer
// fOpDifferenceChamfer
// = fOpIntersectionChamfer(a, -b, r);
chamfer = make_blend {
    fmin (a, b, r) =
	let
	e = max(r - abs(a - b), 0);
        in
	min(a, b) - e*.5;
};


////////////////////////////
// Stairs
////////////////////////////

// fOpUnionStairs
stairs = make_blend {
    fmin (a, b, (r,n) ) =
	let
	s=r/n ;
        u=b-r;
        in
        min(min(a,b),0.5*(u+a+abs((mod(u-a+s,2*s))-s)));
};

// fOpDifferenceStairs
// return -fOpUnionStairs(-a, b, r, n);

// fOpIntersectionStairs
// return -fOpUnionStairs(-a, -b, r, n);

////////////////////////////
// Columns
////////////////////////////

// fOpUnionColumns
columns_union = make_blend {
    fmin (a, b, r, n) =
		if (a >=r || b >= r)
		(
			let
			result=min(a,b);
			in
			result
		)
		else
		(
			let
	                columnradius=r*sqrt(2)/((n-1)*2+sqrt(2));
	                px = a + b/sqrt(2) - r/sqrt(2)+columnradius*sqrt(2);
	         py = b - a/sqrt(2);
	
	                py1=
	                if(mod(n,2) == 1)
	                        mod(py+2*columnradius,2*columnradius)-columnradius
	                else
	                        mod(py+columnradius,2*columnradius)-columnradius
	                ;
	                result=min(mag(px,py1) - columnradius,px,a,b);
	                in
	                result
		)
};


// fOpIntersectionColumns
// derive from differenceColumns

// fOpDifferenceColumns
columns_difference = make_blend {
    fmin (a, b, r, n) =
		if (a >=r  || b >= r) -min(-a,b)
		else
                let
                columnradius=r*sqrt(2)/((n-1)*2+sqrt(2));
                px = -a + b/sqrt(2)-r/sqrt(2)-columnradius/sqrt(2);
                py = b +  a/sqrt(2)+columnradius;

                py1=
                if(mod(n,2) == 1)
                        mod(py+2*columnradius,2*columnradius)-columnradius
                else
                        mod(py+columnradius,2*columnradius)-columnradius
                ;
                        
                result=columnradius - mag(px,py1)
                in
                -min(max(result,px),-a,b)
};

////////////////////////////
// Pipe
////////////////////////////


// fOpPipe
pipes = make_blend {
    fmin (a, b, r) =
	let
	in
	mag(a,b)-r;
};

////////////////////////////
// Engrave
////////////////////////////

// fOpEngrave 
engrave = make_blend {
    fmin (a, b, r) =
	 let
	 in
	 max(a,(a+r-abs(b))/sqrt(2));
};

////////////////////////////
// Groove
////////////////////////////

groove = make_blend {
    fmin (a, b, ra, rb) = 
	 max(a,min(a+ra,rb-abs(b)));
	
};

////////////////////////////
// Tongue
////////////////////////////

tongue = make_blend {
    fmin (a, b, ra, rb) =
	min(a,max(a-ra,abs(b)-rb));
};



show_grid pitch (shape) =
    make_shape {
        dist p : shape.dist p,
        colour p : let
                c=if (
                        mod(abs(p[0])+(0.001+pitch)/2,pitch) < 0.01 ||
                        mod(abs(p[1])+(0.001+pitch)/2,pitch) < 0.01 ||
                        mod(abs(p[2])+(0.001+pitch)/2,pitch) < 0.01
                )
                        [0,0,0]
                else
                        [1,1,1] // [0.9,0.9,0.9]
                in
                c ,
        bbox : shape.bbox, 
        is_2d : shape.is_2d,
        is_3d : shape.is_3d,
    };



in

// smooth  0.5  .union (sphere, cube >> move(1,1,1)) // WORKS
// smooth  0.5  .difference (sphere, cube >> move(1,1,1)) // WORKS
// smooth  0.5  .intersection (sphere, cube >> move(1,1,1)) // WORKS

//chamfer 0.1 .union (sphere, cube >> move(1,1,1)) // WORKS
//chamfer 0.5  .difference (sphere, cube >> move(1,1,1)) // PROBLEM
//chamfer  0.5 .intersection (sphere, cube >> move(1,1,1)) // PROBLEM

stairs ( 0.5,3) .union (sphere, cube >> move(1,1,1)) // WORKS
//stairs ( 0.5,3 ) .difference (sphere, cube >> move(1,1,1)) // WORKS
//stairs ( 0.5,3 ) .intersection (sphere, cube >> move(1,1,1)) // WORKS

//columns_union ( 0.5,3 ) .union (sphere, cube >> move(1,1,1)) // WORKS
//columns_difference ( 0.5,3 ) .difference (sphere, cube >> move(1,1,1)) // PROBLEM
//columns_difference ( 0.5,3 ) .intersection (sphere, cube >> move(1,1,1)) // PROBLEM

//pipes  0.2 .union (sphere, cube >> move(1,1,1)) >> lipschitz 2 // WORKS 
//engrave  0.2 .union (sphere, cube >> move(1,1,1)) // WORKS 
//groove ( 0.2,0.1 ) .union (sphere, cube >> move(1,1,1)) // WORKS 
//tongue ( 0.2,0.1 ) .union (sphere, cube >> move(1,1,1)) // WORKS 

>> show_grid 0.3

