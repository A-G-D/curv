let
plus = bool32_sum;
bits = nat_to_bool32;
in
{
// The 'rand' functions hash one or more arbitrary numbers onto one or more
// uniformly distributed random numbers in the range 0 <= x < 1.
// These random numbers are meant to be high quality (no visual artifacts for
// typical graphics operations), scale independent, and the same results across
// different GPUs.

tea2x2 xy =
    // Marc Olano, 2010, GPU Random Numbers via the Tiny Encryption Algorithm
    // https://www.csee.umbc.edu/~olano/papers/GPUTEA.pdf
    // https://umbcgaim.wordpress.com/2010/07/01/gpu-random-numbers/
    // High quality output, scale independent.
    let v = float_to_bool32 xy;
    in do
    // two rounds of TEA hashing
    v[X] := v[X] `plus` xor[
                v[Y] `lshift` 4 `plus` bits 0xA341316C,
                v[Y] `plus` bits 0x9E3779B9,
                v[Y] `rshift` 5 `plus` bits 0xC8013EA4
            ];
    v[Y] := v[Y] `plus` xor[
                v[X] `lshift` 4 `plus` bits 0xAD90777D,
                v[X] `plus` bits 0x9E3779B9,
                v[X] `rshift` 5 `plus` bits 0x7E95761E
            ];
    v[X] := v[X] `plus` xor[
                v[Y] `lshift` 4 `plus` bits 0xA341316C,
                v[Y] `plus` bits 0x3C6EF372,
                v[Y] `rshift` 5 `plus` bits 0xC8013EA4
            ];
    v[Y] := v[Y] `plus` xor[
                v[X] `lshift` 4 `plus` bits 0xAD90777D,
                v[X] `plus` bits 0x3C6EF372,
                v[X] `rshift` 5 `plus` bits 0x7E95761E
            ];
    // Normalize to the range 1.0 <= v < 2.0:
    v := v `and` [bits 0x007FFFFF,  // strip sign bit and exponent
                  bits 0x007FFFFF]
           `or` [bits 0x3F800000,   // set sign and exponent to 0
                 bits 0x3F800000];
    in bool32_to_float(v) - 1;

tea2x1 xy =
    // Created by Doug, based on rand2x2.
    // It's no good! nav2x1 is much better.
    // Using test.curv, zoom in, then translate to the left, then zoom in more,
    // and you get artifacts.
    let v = float_to_bool32 xy;
    in do
    v[X] := v[X] `plus` xor[
                v[Y] `lshift` 4 `plus` bits 0xA341316C,
                v[Y] `plus` bits 0x9E3779B9,
                v[Y] `rshift` 5 `plus` bits 0xC8013EA4
            ];
    v[Y] := v[Y] `plus` xor[
                v[X] `lshift` 4 `plus` bits 0xAD90777D,
                v[X] `plus` bits 0x9E3779B9,
                v[X] `rshift` 5 `plus` bits 0x7E95761E
            ];
    v[X] := v[X] `plus` xor[
                v[Y] `lshift` 4 `plus` bits 0xA341316C,
                v[Y] `plus` bits 0x3C6EF372,
                v[Y] `rshift` 5 `plus` bits 0xC8013EA4
            ];
    in let
    x = v[X] `and` bits 0x007FFFFF `or` bits 0x3F800000;
    in bool32_to_float(x) - 1;

nav1x1 n =
    // after Alexis Naveros
    let x = float_to_bool32 n; in do
    x := x `plus` (x `rshift` 11);
    x := x `xor` (x `lshift` 7);
    x := x `plus` (x `rshift` 15);
    x := x `xor` (x `lshift` 5);
    x := x `plus` (x `rshift` 12);
    x := x `xor` (x `lshift` 9);
    x := x `and` bits 0x007FFFFF `or` bits 0x3F800000;
    in bool32_to_float(x) - 1;

nav2x1 xy =
    // after Alexis Naveros
    let (x,y) = float_to_bool32 xy; in do
    x := x `plus` (x `rshift` 11);
    x := x `xor` (x `lshift` 7);
    x := x `plus` y;
    x := x `xor` (x `lshift` 6);
    x := x `plus` (x `rshift` 15);
    x := x `xor` (x `lshift` 5);
    x := x `plus` (x `rshift` 12);
    x := x `xor` (x `lshift` 9);
    x := x `and` bits 0x007FFFFF `or` bits 0x3F800000;
    in bool32_to_float(x) - 1;

nav3x1 xyz =
    // after Alexis Naveros
    let (x,y,z) = float_to_bool32 xyz; in do
    x := x `plus` (x `rshift` 11);
    x := x `xor` (x `lshift` 7);
    x := x `plus` y;
    x := x `xor` (x `lshift` 3);
    x := x `plus` (z `xor` (x `rshift` 14));
    x := x `xor` (x `lshift` 6);
    x := x `plus` (x `rshift` 15);
    x := x `xor` (x `lshift` 5);
    x := x `plus` (x `rshift` 12);
    x := x `xor` (x `lshift` 9);
    x := x `and` bits 0x007FFFFF `or` bits 0x3F800000;
    in bool32_to_float(x) - 1;

mul2x1 xy =
    // just absolutely terrible.
    let h = float_to_bool32 xy; in do
    h := h `bool32_product` [bits 0xA341316C, bits 0x9E3779B9]; in let
    x = h[0] `xor` h[1]; in do
    x := x `and` bits 0x007FFFFF `or` bits 0x3F800000;
    in bool32_to_float(x) - 1;

}
