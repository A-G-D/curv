The Noise Library
=================
random(seed): The API
---------------------
This is an okay API to start with.
These functions take an argument (num, vec2, vec3 or vec4)
and hash them into floating point numbers that are uniformly distributed
in the range >=0 and <1.
    random(seed)  // result is num
    random2(seed) // result is vec2
    random3(seed) // result is vec3
    random4(seed) // result is vec4

Problem: piecewise functions not supported by Shape Compiler.
What happens: "this function is not supported" error for a piecewise function
value returned by `match`.

Solutions:
* Piecewise_Function::sc_call_expr() is defined to do something reasonable.
  Compile argument, get its sc_type, search component functions for one whose
  pattern matches the sc_type.

random(seed): A good white-noise hash function for the GPU
----------------------------------------------------------
To hash a 32 bit float to a uniformly distributed random number in [0..1].

Using standard float numeric operations seems to result in hashes that only
work well in a restricted range--you need different magic numbers for different
ranges.

To work well for most floats, I think we would use floatBitsToInt, use int
operations, then use intBitsToFloat. Requires OpenGL 3.3 or OpenGL ES 3.0.
* Brian Sharpe says "Modern cards can also perform integer hashing which
  in some cases produce superior results but will often still run slower than
  floating point operations."
  * int multiply is often slower than float multiply.
  * otherwise, int ops are generally the same speed as float ops.
  * but there may be more float arithmetic units than int arith units.

Idea: new Curv primitive: fhash(num) maps an arbitrary float to another
float in the range [0..1], using all of the bits in the input to construct
the result. Essentially, it just XORs the mantissa bits with the non-mantissa
bits. In GLSL, 3 integer ops, plus a fract() call.
* It's useless by itself. I still need some non-obvious float hash code.

Olano, 2005, https://www.csee.umbc.edu/~olano/papers/mNoise.pdf
    Improvements to Perlin noise on the GPU.
    Discusses the BBS or blumblumshub hash.
    Note, Olano *invented the shader*.

S Tzeng, 2008, Parallel White Noise Generation on a GPU via Cryptographic Hash
http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.650.2121&rep=rep1&type=pdf
    They use MD5 with 64 rounds (!), and demonstrate that the output has
    excellent statistical properties. The output gets worse if you reduce
    to 32 or 16 rounds. This sounds very slow.

Olano, 2010, GPU Random Numbers via the Tiny Encryption Algorithm
https://www.csee.umbc.edu/~olano/papers/GPUTEA.pdf
    TEA, the Tiny Encryption Algorithm
    Faster than MD5, and "good enough" to avoid visual artifacts.
    Better than BBS.
    Tuneable for speed/quality tradeoff.

Plus the blog post:
https://umbcgaim.wordpress.com/2010/07/01/gpu-random-numbers/
"Lots of graphic tasks work well with just two rounds (of TEA)":
    uvec2 v = <input>;
    v.x += ((v.y<<4u)+0xA341316Cu)^(v.y+0x9E3779B9u)^((v.y>>5u)+0xC8013EA4u);
    v.y += ((v.x<<4u)+0xAD90777Du)^(v.x+0x9E3779B9u)^((v.x>>5u)+0x7E95761Eu);
    v.x += ((v.y<<4u)+0xA341316Cu)^(v.y+0x3C6EF372u)^((v.y>>5u)+0xC8013EA4u);
    v.y += ((v.x<<4u)+0xAD90777Du)^(v.x+0x3C6EF372u)^((v.x>>5u)+0x7E95761Eu);
Note: 2 32 bit inputs, 2 outputs, and 32 int operations.

https://github.com/BrianSharpe/GPU-Noise-Lib/blob/master/gpu_noise_lib.glsl
    Implements the FAST_32 hash.
    Also implements BBS, and SGPP from Ashima.
    http://briansharpe.wordpress.com/2011/11/15/a-fast-and-simple-32bit-floating-point-hash-function/
    Looks good, esp. for generating lots of numbers in one call.
    But it looks range restricted.

http://github.com/ashima/webgl-noise
    Much referenced.

https://github.com/Auburns/FastNoiseSIMD
    SIMD C++ noise library.

GLM has noise functions.

Blender has a significant noise library implemented in GLSL, under an open
source licence. Blender uses OpenGL 3.3 (the same as Curv), and it uses a
hash function that performs bit manipulation on floating point representations.
So I should be able to use this code fairly directly.
  Note: It looks like this code is copied and pasted from just above everywhere.
  Many different functions for hashing floats onto pseudorandom numbers, and
  much of that code actually looks bad (roll your own bad code rather than use
  good code written by experts). Eg, dot+sin hash is low quality, Bob Jenkins
  hash is way too expensive on a GPU, and has needlessly high quality.

Bitwise Operations in Curv
--------------------------
Several GPU hashing algorithms use uint32 bitwise and arithmetic operations.
It would be cool if these algorithms could be prototyped in Curv.

C, Python,etc, have integers and floats as separate types. So, for example,
`1` and `1.0` are distinct values with different types. And then the
bitwise operations are defined over integers, so that integers are used as
a representation for bit vectors. I don't want to force casual users to
understand the 1/1.0 distinction in Curv, solely for the benefit of a small
amount of low level code in the noise library.

What is actually needed are bitwise operations that operate on arrays of bits.
Curv is an array language. The proper domain of bitwise operations is
boolean arrays. So instead of inventing a new 'integer' type to represent
boolean arrays, we will use actual boolean arrays, which are already in the
language. Eg, `[true,true,false]` instead of `6`.

We need the ability to convert between a float and a bit array. One potential
problem: the CPU interpreter uses 64 bit floats, while SubCurv on the GPU
uses 32 bit floats. But it's not actually a problem. We need shapes to
render the same way on the CPU and on the GPU. The noise functions need to
return consistent results, so they will operate on 32 bit floats, in both
environments. On the CPU, 64 bit floats will be converted to 32 bit floats,
before being converted to a 32 bit boolean array, and vice versa.

So I'm defining a new type, Bool32, which is a list of 32 booleans, but is
represented in SubCurv compiler output as a uint32.

We need the ability to convert between an integer and a Bool32. On the CPU,
32 bit integers and 32 bit natural numbers are embedded in the 64 bit float
representation. On the GPU, this isn't true. It will be important for constant
numbers to be converted to Bool32 at compile time, not at SubCurv run time.
This will be an issue that noise library developers need to be aware of.

Conversion between numbers and Bool32:
    Bool32.from_int    Bool32.to_int
    Bool32.from_nat    Bool32.to_nat
    Bool32.from_float  Bool32.to_float
Eg,
    Bool32.from_int 6 ==> [false,false,false,...,false,true,true,false]
It's unfortunate that the list syntax is so verbose, but as long as nobody
has to type it or look at it, it's not a problem. Maybe, if the need ever
arises, we could add a terse syntax like `0b101` ==> `[true,false,true]`.

Vectorized boolean operations (monoids), that also work on Bool32:
    and/or/xor
        These names are well known, work well for infix: a `and` b.
    all/any
        These are the most popular names for the and/or monoids.
        They are 'fluent' in prefix form, such as `if (any(are_equal(a,b)) ...`.
        These names don't fit in with `xor`.

`xor(a,b)` is also equivalent to `are_unequal(a,b)` (vectorized form of a!=b).
However, `xor` is a monoid with identity `#false`.

Bool32 operations:
    Bool32.is x -- true if x is a list of 32 bools.
    Bool32.lshift(a,n)
    Bool32.rshift_signed(a,n)
    Bool32.rshift(a,n)
    Bool32.add(a,b)
        Result is modulo 2^32, which is different from standard `+`.
        Another good reason to not overload `+` for this op.
    Bool32.subtract(a,b)
    Bool32.negate(a)
    ...

The APL rotate operator, called `roll` in numpy, might be useful.

The verbose names are not a problem. Curv is not C, and these operations are
limited to a small amount of low level code.
Maybe use `include Bool32` then (x `lshift` 4) and so on.
