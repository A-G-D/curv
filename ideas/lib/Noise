The Noise Library
=================
random(seed): The API
---------------------
This is an okay API to start with.
These functions take an argument (num, vec2, vec3 or vec4)
and hash them into floating point numbers that are uniformly distributed
in the range >=0 and <1.
    random(seed)  // result is num
    random2(seed) // result is vec2
    random3(seed) // result is vec3
    random4(seed) // result is vec4

Problem: piecewise functions not supported by Shape Compiler.
What happens: "this function is not supported" error for a piecewise function
value returned by `match`.

Solutions:
* Piecewise_Function::sc_call_expr() is defined to do something reasonable.
  Compile argument, get its sc_type, search component functions for one whose
  pattern matches the sc_type.

random(seed): A good white-noise hash function for the GPU
----------------------------------------------------------
To hash a 32 bit float to a uniformly distributed random number in [0..1).

Old code uses trig and exponential operations for hashing, because bitwise
operations aren't available in OpenGL 2.1 or WebGL 1. The resulting hashes
only work well in a restricted range--you need different magic numbers for
different ranges.

For high quality, scale independent hashing, you need to convert the float
to a bit array (floatBitsToUint), and use bitwise operators. This requires
OpenGL 3.3, OpenGL ES 3.0 or WebGL 2. That's what I'll do.
* Brian Sharpe says "Modern cards can also perform integer hashing which
  in some cases produce superior results but will often still run slower than
  floating point operations."
  * int multiply is often slower than float multiply.
  * otherwise, int ops are generally the same speed as float ops.
  * but there may be more float arithmetic units than int arith units.

Marc Olano, TEA2 hashing
------------------------
Olano, 2005, https://www.csee.umbc.edu/~olano/papers/mNoise.pdf
    Improvements to Perlin noise on the GPU.
    Discusses the BBS or blumblumshub hash. -- now obsolete
    Note, Olano *invented the shader*.

S Tzeng, 2008, Parallel White Noise Generation on a GPU via Cryptographic Hash
http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.650.2121&rep=rep1&type=pdf
    They use MD5 with 64 rounds (!), and demonstrate that the output has
    excellent statistical properties. The output gets worse if you reduce
    to 32 or 16 rounds. This is very slow.

Olano, 2010, GPU Random Numbers via the Tiny Encryption Algorithm
https://www.csee.umbc.edu/~olano/papers/GPUTEA.pdf
    TEA, the Tiny Encryption Algorithm
    Faster than MD5, and "good enough" to avoid visual artifacts.
    Better than BBS.
    Tuneable for speed/quality tradeoff.

Plus the blog post:
https://umbcgaim.wordpress.com/2010/07/01/gpu-random-numbers/
"Lots of graphic tasks work well with just two rounds (of TEA)":
    uvec2 v = <input>;
    v.x += ((v.y<<4u)+0xA341316Cu)^(v.y+0x9E3779B9u)^((v.y>>5u)+0xC8013EA4u);
    v.y += ((v.x<<4u)+0xAD90777Du)^(v.x+0x9E3779B9u)^((v.x>>5u)+0x7E95761Eu);
    v.x += ((v.y<<4u)+0xA341316Cu)^(v.y+0x3C6EF372u)^((v.y>>5u)+0xC8013EA4u);
    v.y += ((v.x<<4u)+0xAD90777Du)^(v.x+0x3C6EF372u)^((v.x>>5u)+0x7E95761Eu);
Note: 2 32 bit inputs, 2 outputs, and 32 int operations.

Other Hashes
------------
https://github.com/BrianSharpe/GPU-Noise-Lib/blob/master/gpu_noise_lib.glsl
    Implements the FAST_32 hash.
    Also implements BBS, and SGPP from Ashima.
    http://briansharpe.wordpress.com/2011/11/15/a-fast-and-simple-32bit-floating-point-hash-function/
    Looks good, esp. for generating lots of numbers in one call.
    Uses + - * / floor fract, so results should be portable across GPUs.
    It is scale sensitive.

http://github.com/ashima/webgl-noise
    Much referenced. Old-style scale-dependent hashing.

https://github.com/Auburns/FastNoiseSIMD
    SIMD C++ noise library.

GLM has noise functions.

Blender has a significant noise library implemented in GLSL, under an open
source licence. Blender uses OpenGL 3.3 (the same as Curv), and it uses a
hash function that performs bit manipulation on floating point representations.
So I should be able to use this code fairly directly.
  Note: It looks like this code is copied and pasted from just above everywhere.
  Many different functions for hashing floats onto pseudorandom numbers, and
  much of that code actually looks bad (roll your own bad code rather than use
  good code written by experts). Eg, dot+sin hash is low quality, Bob Jenkins
  hash is way too expensive on a GPU, and has needlessly high quality.

Alexis Naveros hash functions
-----------------------------
http://amindforeverprogramming.blogspot.com/2013/07/random-floats-in-glsl-330.html

Lee C uses one round of Bob Jenkin's OAT hash. That has to be worse than
2 rounds of TEA. He doesn't properly test the output, but in the comments,
Alexis Naveros complains about visual artifacts, and provides a better
set of hash functions:

    Note that the hash functions only need to care about the lowest 23 bits,
    with a focus on good avalanche behavior in the higher bits of that range.

    Here's what I use:

    uint hashInt1D( uint x )
    {
    x += x >> 11;
    x ^= x << 7;
    x += x >> 15;
    x ^= x << 5;
    x += x >> 12;
    x ^= x << 9;
    return x;
    }

    uint hashInt2D( uint x, uint y )
    {
    x += x >> 11;
    x ^= x << 7;
    x += y;
    x ^= x << 6;
    x += x >> 15;
    x ^= x << 5;
    x += x >> 12;
    x ^= x << 9;
    return x;
    }

    uint hashInt3D( uint x, uint y, uint z )
    {
    x += x >> 11;
    x ^= x << 7;
    x += y;
    x ^= x << 3;
    x += z ^ ( x >> 14 );
    x ^= x << 6;
    x += x >> 15;
    x ^= x << 5;
    x += x >> 12;
    x ^= x << 9;
    return x;
    }

Converting a 32 Bit Hash to a Float in the range [0,1)
------------------------------------------------------
Code from A Mind Forever Programming:
    const uint mantissaMask = 0x007FFFFFu;
    const uint one          = 0x3F800000u;

    uint h = hash( floatBitsToUint( f ) );
    h &= mantissaMask;
    h |= one;

    float  r = uintBitsToFloat( h );
    return r - 1.0;
The conversion takes the low order 23 bits, discards the rest.
That's okay if the hash function output is designed to be used this way.
The final operation is r - 1. Let's run tests to show that 1 <= r < 2:
      0x3F800000 == 1.0
      0x3F800001 == 1.0000001192092896
      0x3F800000 | 0x007FFFFF == 1.9999998807907104

How do you write a good hash function?
--------------------------------------
In http://www.azillionmonkeys.com/qed/hash.html, Paul Hsieh cites Bob Jenkins
<http://burtleburtle.net/bob/hash/doobs.html>, then builds a new hash function
that performs better on more modern hardware. Here's an excerpt from the end
of SuperFastHash that resembles the Alex Navaris hash:
    /* Force "avalanching" of final 127 bits */
    hash ^= hash << 3;
    hash += hash >> 5;
    hash ^= hash << 4;
    hash += hash >> 17;
    hash ^= hash << 25;
    hash += hash >> 6;
Here some 32-bit hash code from Bob Jenkins(2006), with instructions on how to
generalize it to a variety of situations:
    http://burtleburtle.net/bob/c/lookup3.c
Jenkins uses many bit rotate operations, which don't seem to exist on GPUs.
GPUs are in-order superscalar. We need to make explicit use of SIMD instructions
where possible. Also, from the internet:
   "on Nvidia hardware, there can only be 32 shifts executing at once,
    where there can be 128 other bitwise operations."

How do you test a hash function for making noise?
-------------------------------------------------
* Testing speed.
* Testing quality. See Marc Olano.

Bitwise Operations in Curv
--------------------------
Several GPU hashing algorithms use uint32 bitwise and arithmetic operations.
It would be cool if these algorithms could be prototyped in Curv.

C, Python,etc, have integers and floats as separate types. So, for example,
`1` and `1.0` are distinct values with different types. And then the
bitwise operations are defined over integers, so that integers are used as
a representation for bit vectors. I don't want to force casual users to
understand the 1/1.0 distinction in Curv, solely for the benefit of a small
amount of low level code in the noise library.

What is actually needed are bitwise operations that operate on arrays of bits.
Curv is an array language. The proper domain of bitwise operations is
boolean arrays. So instead of inventing a new 'integer' type to represent
boolean arrays, we will use actual boolean arrays, which are already in the
language. Eg, `[true,true,false]` instead of `6`.

We need the ability to convert between a float and a bit array. One potential
problem: the CPU interpreter uses 64 bit floats, while SubCurv on the GPU
uses 32 bit floats. But it's not actually a problem. We need shapes to
render the same way on the CPU and on the GPU. The noise functions need to
return consistent results, so they will operate on 32 bit floats, in both
environments. On the CPU, 64 bit floats will be converted to 32 bit floats,
before being converted to a 32 bit boolean array, and vice versa.

So I'm defining a new type, Bool32, which is a list of 32 booleans, but is
represented in SubCurv compiler output as a uint32.

We need the ability to convert between an integer and a Bool32. On the CPU,
32 bit integers and 32 bit natural numbers are embedded in the 64 bit float
representation. On the GPU, this isn't true. It will be important for constant
numbers to be converted to Bool32 at compile time, not at SubCurv run time.
This will be an issue that noise library developers need to be aware of.

Conversion between numbers and Bool32:
    Bool32.from_int    Bool32.to_int
    Bool32.from_nat    Bool32.to_nat
    Bool32.from_float  Bool32.to_float
Eg,
    Bool32.from_int 6 ==> [false,false,false,...,false,true,true,false]
It's unfortunate that the list syntax is so verbose, but as long as nobody
has to type it or look at it, it's not a problem. Maybe, if the need ever
arises, we could add a terse syntax like `0b101` ==> `[true,false,true]`.

Vectorized boolean operations (monoids), that also work on Bool32:
    and/or/xor
        These names are well known, work well for infix: a `and` b.
    all/any
        These are the most popular names for the and/or monoids.
        They are 'fluent' in prefix form, such as `if (any(are_equal(a,b)) ...`.
        These names don't fit in with `xor`.

`xor(a,b)` is also equivalent to `are_unequal(a,b)` (vectorized form of a!=b).
However, `xor` is a monoid with identity `#false`.

Bool32 operations:
    Bool32.is x -- true if x is a list of 32 bools.
    Bool32.lshift(a,n)
    Bool32.rshift_signed(a,n)
    Bool32.rshift(a,n)
    Bool32.add(a,b)
        Result is modulo 2^32, which is different from standard `+`.
        Another good reason to not overload `+` for this op.
    Bool32.subtract(a,b)
    Bool32.negate(a)
    ...

The APL rotate operator, called `roll` in numpy, might be useful.

The verbose names are not a problem. Curv is not C, and these operations are
limited to a small amount of low level code.
Maybe use `include Bool32` then (x `lshift` 4) and so on.
