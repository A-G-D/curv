Colour Spaces
=============
A colour space is a coordinate system for describing colours.
Due to the fact that the human eye has 3 types of colour receptors sensitive
to different frequency bands, all colour spaces have 3 coordinates.

There are many different colour spaces in use by the graphics industry.
Different colour spaces must be used in different situations. Unfortunately,
this means that Curv cannot get by with just a single colour space.
In particular, Curv needs to have at least 2 RGB colour spaces: sRGB and linRGB.
This means that an RGB triple is meaningless unless you specify which RGB
colour space it belongs to. Colour is complicated. Sorry.

Black is a unique, absolute colour (the absence of light).

White is not a unique, absolute colour, either in physics, or in the physiology
of human vision. Each colour space defines its own white point. Two popular
definitions of white are Illuminant D50, with a colour temperature of 5000°K,
and Illuminant D65, with a colour temperature of 6500°K. Both are approximations
of daylight, defined by the CIE. D65 is a bit bluer, and D50 is a bit yellower.
You can purchase both D50 and D65 "white" light bulbs.

An RGB colour space has 3 coordinates (R,G,B), meaning red, green and blue,
and is specified by the absolute colours of the red, green and
blue primaries, the white point, and a gamma curve.

Colour spaces are denoted by named values in Curv.
The following colour spaces either exist, or are proposed:
* linRGB
* sRGB
* sRGB.HSV
* sRGB.HWB
* LAB
* LAB.HCL

You can call a colour space like a function, passing a list of colour space
coordinates, and it will construct a colour value. Note that in Curv, colour
space coordinates are normalized to the range 0 to 1. Also note that there are
some cases where a colour space coordinate can be legitimately < 0 or > 1.

Other colour space operations are noted here:
* interpolation
* constructing a gradient colour map
* extracting colour space coordinates from a colour value???
  * eg, cspace.get <colour> => <coordinates>
  * eg, cspace.from <colour> => <coordinates>
* when importing an image, specify its colour space
* TODO

sRGB
----
This is the most popular RGB colour space. It is used by the web.
By default, image files (*.jpeg, *.png, etc) are assumed to use the sRGB
colour space, unless there is metadata that specifies otherwise.
By default, monitors are assumed to use the sRGB colour space,
unless the device driver provides metadata that specifies otherwise.

The "illuminant" white point of sRGB is D65, but the "ambient" white
point (of the creation environment) is D50. I don't know what this means.
If I display white on a calibrated sRGB monitor in a dark room, do I see D65
or D50?

linRGB
------
linRGB is "linear RGB", and it is the colour space used internally by OpenGL
for rendering and colour mixing. It is based on sRGB (same RGB primaries and
same white point), but the gamma curve is linear. If you multiply a linRGB
triple by *n*, then the number of photons emitted by the monitor will be
increased by a factor of *n*. The effect of shining two light sources on
an object is obtained by adding the linRGB triples of each light source.
linRGB must be used if you want to model physically accurate colour mixing,
and Curv uses it for rendering computations on the GPU.

sRGB exists because linRGB is not perceptually uniform. The human eye does not
have a linear response to increasing light levels, it instead has an exponential
response, which is modelled by the sRGB gamma curve.

sRGB.HSV
--------
sRGB.HSV is a simple (and cheap to compute) transformation of sRGB that is
more ergonomic for colour picking. It is an old and popular standard.
I implemented it because I've ported several pieces of code that use it.

* H is Hue: 0 means red, 1/3 means green, 2/3 means blue, and 1 is red.
* S is Saturation. It is the distance from a neutral colour (white/grey/black).
  1 means fully saturated, while 0 indicates a grey-scale value between black
  and white. Turning down the saturation leaches out the hue and brings the
  colour closer to neutral.
* V is Value (also known as Brightness -- sometimes the colourspace is called
  HSB). It is the distance from black. Turning down the brightness makes the
  colour dimmer and closer to black.

Notes:
* A ``saturation`` of 0 constructs a neutral greyscale colour
  based on the ``brightness``, ignoring the ``hue``. So ``sRGB.HSV(h,0,b)``
  is white if b==1, medium grey if b==0.5, and black if b==0.
* A ``saturation`` of 1 constructs a "shade" (a mixture of a pure
  colour and black), where ``hue`` is the pure colour,
  and ``brightness`` is the distance from black.
* If the ``brightness`` is 0, then the resulting colour is black,
  ignoring the hue and saturation.
* A ``brightness`` of 1 constructs a "tint" (a mixture of a pure colour
  and white), where ``hue`` is the pure colour,
  and ``saturation`` is the distance from white.

Historically, HSV was created by Alvy Ray Smith as an alternative to the older
HSL space. It was described in the SIGGRAPH 1978 conference proceedings:
<http://alvyray.com/Papers/CG/color78.pdf>. Originally, a major benefit of
HSV over HSL was that HSV was faster to compute.

sRGB.HSL
--------
HSL is an older alternative to HSV. Both colour spaces were designed to be
used by artists for colour picking. The web CSS standard supports HSL but
not HSV. I personally prefer HSV, and I haven't needed an HSL transform in
Curv for porting software, so it hasn't been implemented.

sRGB.HWB
--------
HWB is a relatively new (1995) colour space that was designed by Alvy Ray Smith
to be more intuitive for colour picking than HSV or HSL, and to be faster
to compute than the older standards.
<http://alvyray.com/Papers/CG/HWB_JGTv208.pdf>

HWB has been included in CSS level 4, due to its superior ergonomics.
<https://www.w3.org/TR/css-color-4/#the-hwb-notation>

A circular colour picker for HWB is quite nice. There is a circular hue
wheel, and inside that, a triangle filled with colour gradations,
with the 3 vertices corresponding to the current hue, white, and black.

LAB
---
* Perceptually uniform.
* L is luminance (absolute brightness).
* A is the red-green axis.
* B is the blue-yellow axis.
* The LAB gamut covers all perceivable colours. When converting LAB
  coordinates to internal representation, during the construction of
  a colour value, we use linRGB coordinates outside the range 0...1,
  and clamp during lighting calculations.
* Best overall choice for colour interpolation (linear gradients).
  Subjectively, the gradients look good, and have a minimum of unexpected
  behaviour.
  http://howaboutanorange.com/blog/2011/08/10/color_interpolation/
  * Brightness (luminance) increases or decreases monotonically and
    uniformly across the gradient.
    Neither property holds for RGB interpolation.
  * You don't get unexpected hues when interpolating between colours
    on opposite sides of the colour wheel. Eg, you don't get violet
    when interpolating between blue and orange, you get neutral colours
    instead.

HCL
---
I want to include HCL, but there's a problem. There are 3 different colour
spaces called HCL, and there is much confusion about which colour space is
being referred to on different web sites that promote it.

* HCL(uv)
  This is a version of the CIE LCh(uv) colour space, with the coordinates
  in HCL order. LCh(uv) is, in turn, a transformation of CIE LUV, with
  better ergonomics for colour picking, similar to how HSV is a transformation
  of RGB. <https://en.wikipedia.org/wiki/CIELUV#Cylindrical_representation>
  * Ross Ihaka, "Colour for Presentation Graphics", 2003
    <https://www.r-project.org/conferences/DSC-2003/Proceedings/Ihaka.pdf>
  * The Colorspace library by Ihaka, for R and Python:
    <http://colorspace.r-forge.r-project.org/>
    <https://python-colorspace.readthedocs.io/en/latest/>
  * <http://hclwizard.org/>
* HCL(ab)
  This is a version of CIE LCh(ab), which is a transformation of CIE LAB.
  <https://en.wikipedia.org/wiki/CIELAB_color_space#Cylindrical_representation:_CIELCh_or_CIEHLC>
  * CSS Level 4 specifies HCL(ab) as a supported colour space.
    <https://www.w3.org/TR/css-color-4/#lab-colors>
  * D3.js supports HCL(ab)
    <https://bl.ocks.org/mbostock/3014589>
  * chroma.js supports HCL(ab)
* HCL(2005)
  This is a much newer colour space described by Sarifuddin and Missaoui
  in "A New Perceptually Uniform Color Space with Associated Color Similarity
  Measure for Content-Based Image and Video Retrieval".
  <https://pdfs.semanticscholar.org/206c/a4c4bb4a5b6c7b614b8a8f4461c0c6b87710.pdf?_ga=2.9335922.611436885.1505557968-1463367387.1505557968>
  I don't think this paper is very influential. I only know about it because
  of Wikipedia.

Even though Ihaka claims that HCL(uv) is better than HCL(ab) for emissive
displays, I think that the web community and the CSS standard are ultimately
more influential than the R/Python communities. If you are picking or generating
HCL colours to display in a web page, you better use HCL(ab). So I'm going to
support HCL(ab). It's all about supporting a common standard, so that you can
more easily port code from other platforms.

LAB.HCL
-------
This is the HCL(ab) colour space described above.
* A simple transform of LAB coordinates, which is more logically organized
  than LAB for the purpose of colour picking. All of the hues are on
  the H axis.
* Perceptually uniform.
* Useful for colour interpolation in cases where you prefer to cycle through
  the colour wheel when interpolating between distant hues, rather than
  pass through a neutral colour when interpolating between two relatively
  more saturated colours. In HCL interpolation, unlike LAB,
  the Chroma (saturation) increases or decreases monotonically.
