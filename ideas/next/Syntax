Syntactic Extensibility
-----------------------
Curv needs to support DSLs.

In Lisp, this is done using macros. But macros create difficulty and complexity
(cognitive load).
It's harder to define a macro than to define a function. It's harder to
understand the error messages if the syntax generated by a macro produces
an error. It's hard to understand the syntax of a macro call without good
documentation.
 * But: It's acceptable for a library writer to spend more effort on a macro
   in order to create an abstraction that's easier to use by library clients.
   We need to provide good error detection and reporting mechanisms for
   macros, so that user-friendly error messages are generated.

Most natural languages provide freedom in word order, using particles, affixes
or inflections to mark the role of each word in a sentence. You can use this
freedom to make a particular sentence easier to understand, eg by putting the
most important information at the front.

In Curv, my ambition is to support DSLs using expression syntax, not macros.

There is a rich but fixed set of syntaxes:
* For constructing generic structures, which together span all the important
  concepts/notations needed in a DSL. These structures are expressions that
  denote values, which can be introspected.
* For invoking operations. These syntaxes are equivalent to function calls,
  and work using the equivalents of particles, affixes, inflections.

You can encode DSLs by composing these syntaxes together.
* Once you learn the general syntax, you can parse a DSL expression into a
  parse tree, identify all operations and arguments, and determine the scope
  of all bound identifiers, all without looking at library documentation or
  the library code that implements the DSL.
* You can freely abstract over the subexpressions of a DSL expression.
  You can externally extend the DSL without touching the original DSL
  implementation.
* Smalltalk is an inspiration. There is a variety of different syntaxes
  for messages: postfix, infix, mixfix. Name-binding operations are encoded
  by passing blocks as arguments.

Expression based DSLs are not a panacea, but I can still try, using language
design, to push the applicability of this approach as far as possible.
The approach has limits. It may produce syntax that is noisy, verbose
and clumsy compared to a completely bespoke DSL syntax, or when compared
to macro- or string- based DSLs.
* A string-based DSL can use different tokenization and a different surface
  grammar than the base language. Eg, the `format` function from Python and
  many other languages, or most regular expression APIs.
* A macro-based DSL uses the same tokenization and surface grammar as the
  base language, but can use different semantic analysis rules.
  You can abstract over non-expressions, create abstractions that are
  polymorphic over multiple phrase types, invent new phrase types.

Free abstraction over subexpressions seems like a huge benefit of expression
based DSLs. Here's an idea. Every string- or macro- based DSL should aspire
to be a thin layer of syntactic sugar over an expression based DSL,
so that you can remove the syntactic sugar if you need to abstract.
Is this feasible?

Curv's syntactic extensibility only applies to the pure functional dialect,
not to the imperative dialect. To make the imperative dialect extensible
(with new name-binding constructs, unevaluated statement arguments)
requires either macros or closures that capture mutable variable references.
And both of those are ruled out. So the imperative language is second class,
its syntax is not extensible.

I have also considered the goal of implementing most of Curv in Curv itself,
using Curv as an extension language, similar to, say, Lisp or Forth. I think
this will require macros, and other metaprogramming features that are used
primarily for implementing Curv in itself. These features would constitute the
fifth level of Curv, the meta level, which is below the library level.

What Lies Beneath?
------------------
1. If you remove all the syntactic sugar from a program, what remains?
2. What is the underlying representation of a program, used by the languge
   implementation?

Since Curv is value-oriented, the answers might be 'expressions' and 'values',
but more detail is required.
 * Are Curv phrase types syntactic sugar for expressions?
   I can't map *all* phrases to expressions
   (I at least need expressions, patterns and definitions).
   Maybe I can map generators, statements and locatives to expressions.

In Lisp 2, the answer is S-expressions. The Algol syntax is translated into
S-expressions. Macros map Sexprs onto Sexprs. The compiler uses Sexprs as
the IR, finally creating assembly-language Sexprs, which are translated to
machine code at the last step.

In lambda calculus, everything is a lambda expression.

In Technetium, the answer is T-code. Sexprs, Lambda exprs and Tcode are
basically the same idea: a syntax tree (abstract source code) containing
identifiers that are implicitly bound in lexical scopes defined by name-binding
syntax which is also in the tree.

Syntax trees are not a good IR; tree transforms require difficult algorithms
for variable renaming.

In the actual Curv implementation, the two program representations are
syntax trees (Phrase trees) and IR (Operation trees).
