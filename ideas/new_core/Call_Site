class Meaning (and Operation) have a Shared<const Phase> syntax_ member.

The syntax_ member indicates the source code location where the Operation
was invoked.

It is used to generate an error message if the operation fails (at run time)
or is determined to be invalid (at compile time).
Typically, either the source location of the operation phrase is disclosed
in the error, or the source location of one of the arguments.

A Meaning may have two possible relationships with its syntax_ member:
 * Analytic: The Meaning is the direct result of calling phrase->analyse()
   on its syntax member. The syntax_ member is the original syntax tree for
   this Meaning.
 * Synthetic: This is the opposite of Analytic. The Meaning was not generated
   by syntax_->analyse(). The Meaning was generated algorithmically by native
   code. Some kind of code generation has occurred, where the code is not
   isomorphic to the Curv source code that triggered the code generation.
    * A similar case occurs with Frame::call_phrase_, which is a Call_Phrase in
      the "analytic" case. But if a native function is calling a Curv function
      value that was passed as an argument, no Call_Phrase is available at the
      call site. Perhaps a "synthetic phrase" should be used here.

Significance of the `syntax_` member:
 * It is the source code that was analysed to produce the meaning.
   If the meaning is an expression, then the syntax_ is usually a function call
   or operator expression. (But only in the analytic case?)
 * It describes the call site from which the operation was invoked.
   For a synthetic meaning, the call site may be a C++ function.
 * Can we always break down the syntax_ and obtain operand phrases?
   No, don't do that. Use the Operation nodes for the argument source locations.
 * Can we obtain the function/operator name from the syntax_?
   No, don't do that. Functions and operators already know their names.
 * The only thing you should do with the syntax_ is to call syntax_->location().
    * The only reason we don't store a Location directly in the Meaning is the
      idea that it is expensive to construct, and that we should wait until an
      exception is thrown.
    * This doctrine is compatible with synthetic Meanings.

Misuse of syntax_ (violating rule that only syntax_->location() matters):
 * Binary_Array_Op::domain_error() uses At_Syntax to determine the operation
   name. That will be fixed: use Prim::name() instead, and change At_Syntax
   back to Context.
 * Call_Phrase hijinks:
   * Meaning::call(const Call_Phrase&, Environ&) -- this is an analysis
     function, for analysing a Call_Phrase. Okay so far.
   * Call_Expr thinks that its syntax_ should be a Call_Phrase. It sometimes
     isn't, so func_part(ph) and arg_part(ph) are used to safely decompose.
   * Frame thinks its ::call_frame_ should be a Call_Phrase. It sometimes isn't.
     func_part() and arg_part() are used to decompose.
   * Predicate_Assertion_Phrase is a subclass of Call_Phrase in order to
     participate in this whacky protocol.
 * predicate assertions:
    * Predicate_Assertion_Phrase is a subclass of Call_Phrase.
    * Predicate_Assertion_Eval does this:
        val = arg1_->eval(f);
        pred = arg2_->eval(f);
        r = call_func(pred, val, syntax_, f) ...
    * call_func(func, arg, ph, f) is janky:
       * If func is not a function, throw Exception(At_Phrase(*func_part(ph)...
         We should instead pass func+func_cx.
       * Converts arg to List using At_Phrase(*arg_part(ph),f) context.
         We should instead pass arg+arg_cx.
       * Passing func_op and arg_op works for Call_Expr::eval and
         Predicate_Assertion_Phrase::eval, but not SC_Test_Action::exec.
         Here, we extract function values from a record value.
 * Function::sc_call_expr(arg_op, call_phrase, frame)

------
    // The syntax need not have any relation to the meaning class.
    // Eg, an Identifier phrase can be analysed into a variety of different
    // meanings. That's why we separate the Phrase tree from the Meaning tree.
    //
    // If the Meaning is algorithmically generated by native code, and not
    // constructed by analysing a syntax tree, then the `syntax_` might be
    // a Call_Phrase for whatever Curv function call generated the Meaning.
    // So it can be quite arbitrary, and you can't assume that a particular
    // Meaning class is paired with a particular Phrase class.
------

Issues
======

Array_Op error reporting
------------------------
Infix '+' and 'sum' are both implemented using Add_Prim.
In 'A+B' or 'sum[A,B]', when an element of A and an element of B cannot be
added, what is the error message, context and stack trace?

'product' is almost the same as 'sum', except 'product' is written in Curv:
    curv> product[[1,2],[3,true]]
    ERROR: 2 * #true: domain error
    at file "/usr/local/lib/curv/std.curv":
    59| product = reduce(1, (x,y)->x*y);
                                   ^^^
    at file "/usr/local/lib/curv/std.curv":
    56|                 r := f(r, list[i]);
    at:
    1| product[[1,2],[3,true]]
       ^^^^^^^^^^^^^^^^^^^^^^^

Current implementation of 'sum':
    curv> sum[[1,2],[3,true]]
    ERROR: at index [1]: argument #1 of sum: #true: domain error
    1| sum[[1,2],[3,true]]
          ^^^^^^^^^^^^^^^^

Current implementation of '+':
    curv> [1,2]+[3,true]
    ERROR: 2 + #true: domain error
    1| [1,2]+[3,true]
       ^^^^^^^^^^^^^^

Simple, and good enough for now:
    ERROR: 2 + #true: invalid arguments
    1| sum[[1,2],[3,true]]
          ^^^^^^^^^^^^^^^^
Use Prim::name() to generate ERROR line. No need for At_Syntax arguments.

More informative:
    ERROR: 2 + #true: invalid arguments
    at x[1] and y[1] in x + y
    where x=a[0] and y=a[1] in sum(a)
    1| sum[[1,2],[3,true]]
          ^^^^^^^^^^^^^^^^
This more informative message could be implemented with local changes
to array_op.h plus a function name argument to Binary_Array_Op::reduce().

Generating Reactive Expressions
-------------------------------
