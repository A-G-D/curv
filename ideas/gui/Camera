Scriptable Camera Position
==========================
* The GUI displays the camera position in the HUD.
* You can copy these numbers and use them in the CLI to set the initial
  camera position in the viewer or in 3D image export using -Ocamera=...
* You can specify the initial camera position using Curv code.
  A 'View' is a record with 'shape' and 'camera' fields.
  It's another kind of graphical value.
* The current camera position is available as a read-only reactive 'camera'
  record variable,
  like $vpr/$vpt/$vpd in OpenSCAD (ViewPort Rotation, Translation, Distance).
  Applications include: a billboard that is rotated to always face the front.

"arcball rotation" to replace my ad-hoc mouse rotation code.

What are the components of a 3D camera position?
Requirements:
 * arcball rotation: does this have a preferred camera representation?
 * the billboard application: ease of coding?
 * shadertoy-style shaders: ease of coding?

gluLookAt(eye, centre, up)
    eye: point, camera location
    centre: reference point
    up: vector

Curv:
    centre -- a point the camera is looking at
    eye -- a vector from centre to the eye point (in the camera)
    up -- a normalized vector perpendicular to eye

In OpenSCAD, it is:
    {translate=[x,y,z], rotate=[x,y,z], distance=d}
Maybe add a FOV, since that has been requested multiple times.

Microsoft .net
  PerspectiveCamera(
    position :: Point3D -- position of camera
    lookDirection :: Vector3D
    upDirection :: Vector3D
    fieldOfView :: Double -- angle of projection in degrees)
  OrthographicCamera(
    position :: Point3D -- position of camera
    lookDirection :: Vector3D
    upDirection :: Vector3D
    width :: Double // width of viewing box in world units)

In issue #73, P-E-W suggested:
  target = [0,0,0];  // Point the camera is aimed at
  direction = [1,0,0];  // Direction of the camera's location from the above point
  distance = 10;  // Distance of the camera's location from the above point
  zoom = 5;  // Magnification of the camera's field of view.
      Large values for both distance and zoom approximate a parallel projection.
Which doesn't work because it doesn't account for rotation around the axis from
camera to target.
