Block Local Variables
=====================

I want to streamline the syntax for imperative programming.
I don't like this syntax:
    while (condition)
        let
            def1
        in do
            stmt1
        in let
            def2
        in
            stmt2

A 'block' or 'compound statement' is a sequence of statements and sequential
definitions, which are all executed in sequence.

The question is: what syntax to use for embedding sequential definitions in
a compound statement.

0. Modified let/do
------------------
    while (condition)
        let
            def1
        do
            stmt1
        let
            def2
        do
            stmt2

1. Local Keyword
----------------
`local pattern = expression` is a sequential definition that can be embedded
in a compound statement.

If we consider the `;` operator to be a right associative binary operator,
then a compound statement is:
  statements ::=
    statement |
    statement ; statements |
    sequential-definition ; statements

Resulting syntax:
    while (condition) (
        local def1;
        stmt1;
        local def2;
        stmt2;
    )

In what contexts are compound statements used?
    [ compound-statement ]
    { compound-statement }
    Imperative programming:
      if (condition) (compound-statement)
      while (condition) (compound-statement)
      etc...

The weirdest case is record comprehensions. Inside brace brackets,
a regular definition signals a scoped record constructor.
The keyword `local` signals that this definition is not defining a field.

Should `local` definitions support recursive and mutually recursive definitions?
Eg,
    local def; stmts
    local (def1; def2; ...); stmts
is like
    let def in (stmts)
    let (def1; def2; ...) in (stmts)
This shows that the main point of `local` is to get rid of the parentheses
around (stmts). That's the streamlined syntax I want.

Or should `local` definitions support parallel definitions, like Scheme's `let`?
This means that Curv `let` is like Scheme let-rec or ML let rec,
while the equivalent of Scheme and ML `let` is:
    do  local (a = 1; b = 2);
    in expression
and the equivalent of Scheme's let* is
    do  local a = 1;
        local b = a + 1;
    in expression

2. Modified Let
---------------
Change the syntax of `let` to support the streamlined syntax I want.

  statements ::=
    statement |
    statement ; statements |
    let definition ; statements |
    let (definitions) ; statements
  expression ::=
    let definition in expression |
    let (definitions) in expression

Resulting syntax:
    while (condition) (
        let def1;
        stmt1;
        let def2;
        stmt2;
    )

A nice thing about a `let x = 1` statement is that this syntax is found some
well known languages: Javascript, Rust, Swift.

Although it seems economical to reuse the `let` keyword, now we have a kind
of overloading, and you need to scan forward to find the `;` or `in`
to determine the scope of the `let` definitions.

If I change `do` to work the same way, then we have:
    statement ::= do ( statements... )
    expression ::= do ( statements... ) in expression
Right now, the only context where `,` and `;` are both allowed, and they
have a different meaning, is inside parentheses. I could change that by
using `do ( statements... )` as the compound statement syntax.
    while (condition) do (
        let a = x + y;
        x := x + a;
    )
So now I have two ways to define local variables:
    let x = 1 in statement
    do (let x = 1; statement)
This choice is a bit ugly/overly complex.

3. Plain Definitions
--------------------
  statements ::=
    statement |
    statement ; statements |
    definition ; statements

This has multiple problems. First, it is ambigous, and conflicts with
the current grammar, where (definition1;definition2) is a compound definition,
and (definition1;definition2;action) is also a compound definition, not a
compound statement.

If we introduce a special syntax for compound statements, such as
   do (statement1; statement2; ...)
and restrict this interpretation of definitions to the context
   do (statements)
and
   do (statements) in phrase
then it could work.

Right now, the syntax for compound statements and the syntax for list and
record comprehensions are orthogonal to each other. So we have
    statement ::= statement1; statement2; ...
    expr ::= [ statement ]
    expr ::= { statement }
But, this proposal breaks that orthogonality.

Another problem is that an imperative programmer will mistake `x = 1` for an
assignment statement if used in a statement context.
