Curv Type Theory
================
Curv is a dynamically typed language. There are reasons for this.
 * For beginners, a dynamically typed language has an easier learning curve.
 * Live coding requires dynamic typing. In live coding, you edit a program
   while it runs. The effects of any errors you introduce during editing are
   localized as well as possible, so that the program can continue to run.
 * Dynamic typing maximizes simplicity and expressive power.
   It allows everything to be a first class value. You can always eliminate
   code duplication using functions, because anything can be passed as a
   function argument or returned as a result.
 * Dynamic typing is best for exploratory programming, where you are trying
   to create an artistic effect. The added complexity of statically typed
   languages doesn't add cognitive burden or get in your way.

Dynamic typing means that every value carries around its "type" at run time,
and that it is always possible to defer "type checking" until run time.

I put the word "type" in quotes because it means different things in different
contexts.

When I say that "every value carries its type at run time", I mean that
every value remembers how it was constructed. Every value can be printed as
a constructor expression that, when evaluated, returns the original value.
These run time type tags are actually constructor names, plus additional
metadata for reconstructing the value's constructor arguments.

Separate from this, Curv has first class type values. A type is a set of values.
Type values are used for "type checking" (eg, ensuring that function arguments
have the correct type) and for specifying efficient value representations in
Curv functions that are compiled into GPU code.

Separate from this, Curv has Algebras. An Algebra bundles a type together with
its constructors and operations, in a record value.

Types
-----
A type is a set of values, together with a representation (indicating how to
efficiently represent a memory location restricted to just those values).
For example, type `Bool` contains the values `#true` and `#false`, and the
representation part indicates that a Bool can be representing using 1 bit.

If `T` is a Type, then
 * A type predicate `T?` is a function that returns true if its argument is
   contained within `T`'s value set and false otherwise.
    * `is T` is another possible syntax.
 * A type assertion `x :: T` aborts if `T? x` is false, returns `x` otherwise.
   On error, it should provide detailed information about what part of a
   structured value failed to validate. A type assertion may also optimize the
   argument, converting it to a more efficient representation, without changing
   the value (the argument and the result compare equal).
    * `make T x` is another possible syntax for value optimization.

Types form a lattice, with a top and bottom. The partial evaluator needs
the ability to compute least upper bound, greatest lower bound, of two types.
 * 'if (<Bool>) <T1> else <T2>' has type LUB(T1,T2)
 * match[x::T1->...,...](<T>) is abstractly evaluated by computing GLB(T,Tn)
   for the n'th branch, and skipping branches until the GLB is not bottom.

Types may be constructed using set union, set intersection and set difference.
Hypothetically, I could use the syntax
   T1|T2, T1&T2, T1--T2 or T1~T2

There is a set constructor syntax, #[a,b,c], and set comprehensions,
which construct a data structure representation of a type.

A predicate type contains a function that maps an argument to #true if the
argument is in the type's value set, or #false otherwise?
Could use `predicate(func)` to construct a predicate type.
 * This makes it impossible to support exact type equality.

A SubCurv type maps a set of values onto a SubCurv representation that can
exist within a GPU program. This includes selected data types from GLSL/WGSL
and selected OpenGL/WebGPU image/buffer types. Not all types are SubCurv types.
 * The SubCurv compiler assigns a static type to every variable and
   expression. Previously, every Curv value either mapped to a unique
   type, or was not supported by SubCurv. Soon, there will additional
   types for numbers (eg, Int32, Nat32, and probably others), and static
   type declarations will be required to construct variables and
   expressions of these additional types. For example,
      x :: Int32 = 0
   will represent `x` using the GLSL `int` type.
 * If T is a SubCurv type, then `x :: T` optimizes x: it validates x, and
   converts it to a more compact, efficient representation (that compares
   equal, since the value has not changed, only the representation).
   Used to construct compact arrays (from Compact Array proposal).
 * A Picker type is a SubCurv type that specifies a UI for modifying
   a parameter value.

Reactive values contain a type. Previously I used SubCurv types.
If I switch to general types, Curv becomes more expressive (more
expressions can be recognized as shapes and displayed graphically).

The New_core will have a partial evaluator, which will use types as
abstract values (abstract interpretation). With more information available
in these abstract values (a richer type system), the partial evaluator
can reduce more subexpressions, which makes Curv more expressive.

Types are useful for mapping between Curv values and GPU data types (SubCurv).
They might also be useful in other situations where Curv values are imported
or exported from some other externally defined representation. Like JSON,
or a WASM FFI. For example a json_import function could use a type to map
JSON values to Curv values. Eg, `String` maps a JSON string to a Curv string,
while `Symbol` maps a JSON string to a Curv symbol.

Algebras
--------
An Algebra bundles a type together with its primary operations into a record.
In this concept, there is a single named value representing the type, and it
is a record containing operations. Benefits:
 * Neatly organize operation names into a hierarchy.
 * When multiple Algebras support the same interface, this enables a form
   of generic programming, where you pass Algebras as arguments.

An Algebra is a record containing a `type` field, plus some optional constructor
fields (variables bound to instances of the type, and functions that construct
an instance of the type), plus some optional operation fields (functions that
take instances of the type as arguments). This is directly inspired by the
concept of a single-sorted algebra in mathematics.

The `type` field is the only required field in an Algebra.

An algebra can be used interchangely with a type with any primitive operation
that has a type argument. For example, if A is an algebra, then
 * `A?` is equivalent to `A.type?`.
 * `x :: A` is equivalent to `x :: A.type`.

It is common for an Algebra to contain a single constructor function bound
to `call`. For example, `Char` is an Algebra with a `call` field:
 * `Char 97` or `Char #'a'` constructs a character value.
 * `Char? x` returns `#true` if `x` is a character.

Repackage the bool32 operations into an Algebra?
   nat_to_bool32    Bool32.from_nat    // constructor
   float_to_bool32  Bool32.from_float  // constructor
   bool32_to_nat    Bool32.to_nat
   bool32_to_float  Bool32.to_float
   bool32_sum       Bool32.sum
   bool32_product   Bool32.product

The constructor functions in the Abstract Value proposal will be represented
as algebras.

Pickers
-------
old:
    slider(lo,hi) =
      { call = is_num;
        picker = {slider:[lo,hi]};
      };
    int_slider(lo,hi) =
      { call = is_num;
        picker = {int_slider:[lo,hi]};
      };
    scale_picker =
      { call = is_num;
        picker = #scale_picker;
      };
    checkbox =
      { call = is_bool;
        picker = #checkbox;
      };
    colour_picker =
      { call = is_vec3;
        picker = #colour_picker;
      };
new:
    slider(lo,hi) =
      { type = Num;
        picker = {slider:[lo,hi]};
      };
    int_slider(lo,hi) =
      { type = Int32;
        picker = {int_slider:[lo,hi]};
      };
    scale_picker =
      { type = Num;
        picker = #scale_picker;
      };
    checkbox =
      { type = Bool;
        picker = #checkbox;
      };
    colour_picker =
      { type = Colour;
        picker = #colour_picker;
      };
The type of int_slider changes from Num to Int32.
The type of colour_picker changes from Vec3 to Colour.

Structural, not nominal, typing of picker values.
My preference is structural typing whenever the record values used are
high level enough to be easily understood. Nominal types add a layer of
abstraction, which is a kind of complexity: don't pay that complexity cost
unless it's worth it.

Type Constructor Brainstorming
------------------------------
Should I use mixed case `Foo` or lower case `foo` in type and algebra names?
 * There is no absolute prohibition on mixed/upper case in the std namespace.
   For example I have `X` and `sRGB`.
 * Mixed case avoids conflict with using a type name as a parameter name or a
   local variable.
 * A `colour` type would conflict with `colour` functions in a shape,
   and with the `colour` shape constructor in the std namespace.
It appears I should use mixed case.

All or Always or Value or Any_Value -- the set of all values
None or Never or Empty or No_Value or Error or #[] -- the empty set
#[x] or Singleton(x) or Constant(x)

Num, Symbol, Char, List, Record, Function, Type
Bool, String, Callable
Int32, Nat32, Bool32
Colour, sRGB8

Tuple[T1,T2,...]
Array R T
    R is a rank: 0, 1, 2, ...; T is a type
    Eg, `List = Array 1 Value`.
    Eg, `String = Array 1 Char` is a character string.
    Eg, `Array 2 Colour` is a 2D pixel array.
    Note, Array 0 T == T
Array Dims T
    Dims is a list of dimensions.
    Eg, Array [3] Char is a string containing 3 characters.
Record {fieldname1:type1, ...}
    Only matches records with the exact fields specified.
Has_Fields {fieldname1:type1, ...}
    Eg, Callable = Function | Has_Fields{call: Callable};

Enum[member1,...]
    Each member is a symbol or a singleton record with a type value.
    Eg, Optional_Num = Enum[#nothing, {just: Num}]
x|y or Union[x,y,z,...]
    Recursive definitions can make sense,
    Eg, Tensor = Num | Array 1 Tensor

domain <Function> => <Type>

Simplified Types
----------------
Types are abstract values of type `Type`.

How are types printed? Which constructors are primitive and which are aliases
for other constructors? This determines type equality (==).
 * Two types with the same value set but different representation are not equal.
   An example is `Colour` and `sRGB8`.
 * Two types with the same value set and representation should be equal, but
   ensuring this is easier if I restrict the set of constructors to those that
   I absolutely need.
    * What does "same representation" mean? It should mean "same bit layout in
      SubCurv", which is structural. It could be interpreted as nominal (Bool
      and Enum[#false,#true] have different representations because the first
      happens to map to 'bool' and the second happens to map to 'uint' in GLSL).
      But that's not desirable, because Curv typing is as structural as
      possible, and because this just leads to arbitrary type equality
      distinctions (whatever the implementation does) rather than principled
      distinctions. So, if we are going to provide an Enum constructor,
      then Bool=Enum[#false,#true].
    * The set constructor #[...] is difficult, because it can alias any other
      finite type. And it's not a first tier requirement, so leave it out.

For MVP, just create type constructors for thoses cases where `std` needs:
 * a type predicate (replacing is_bool, is_string, etc)
 * a constructor (replacing char, bool, string, symbol, make_shape)
 * an Algebra (eg, Bool32, Shape)
 * all SubCurv types have type constructors
All these constructors are initially opaque, and they are mostly disjoint.

For backwards compatibility, in x::T, the T argument is either a type or
a predicate. The fact that the type values don't form a lattice will not be
a problem initially. The partial evaluator can maintain a richer set of types
than what we initially expose.

Colour
------
The current colour proposal defines Colour as an abtract type.
The predicate is `is_colour`, colour space values are used as constructors
(eg, `sRGB[r,g,b]`, `LAB[l,a,b]`, etc). The printed representation
is `sRGB[r,g,b]`.

Translated to this new Type proposal, I will need a general `Colour` type
that contains all colour values, and derive the predicate function from that.
The SubCurv representation will be a `vec3` using the linear RGB colour space.
Converting a Colour value `c` to linear RGB using `linRGB.get c` emits no
additional GLSL instructions.
 * It is difficult to call it `colour`. Shapes contain `colour` functions
   and an unqualified reference to this type will look like a recursive function
   reference. You could be required to use std.colour inside a colour function,
   but it's a bad design. There is already a `colour` function that assigns a
   colour to a shape, after OpenSCAD. I would want to rename these existing
   features.
 * I could call it `Colour` and use the mixed case type naming convention.

So the predicate is `Colour?` and you declare variables as `c :: Colour`,
but the constructors are colour space names. It's a bit odd, but fine.

To support compact pixel arrays of image data, I will need some "efficient
representation" Colour types. Eg, `sRGB8`, like GL_SRGB8 image format?

SubCurv generic types
---------------------
I need to give good SubCurv error messages when an argument has the wrong type.
What notation do I use for 'Num or Vec2 of Num or Vec3 of Num or Vec4 of Num'?
And is that notation needed in Curv for writing SubCurv code?

SubCurv Compiler
----------------
In libcurv, SC_Type is used for type inference and type checking during
code generation. Should SC_Type be unified with user-level type values?
In what contexts would a user-level type constant be imported into the compiler
for use as an SC_Type?
 * `parametric`: 'picker' type assertions are used by the SC_Compiler.
 * Right now you cannot generate 'int' or 'uint' variables in GLSL.
   But an ':: Int32' type assertion on a variable definition or expression
   could be compiled to a GLSL 'int' variable or expression.
    * Is this a can of worms? What are the semantics of SubCurv arithmetic
      expressions, and how do those semantics differ from Curv?
       * In SubCurv, we could do this:
           I+J, I-J, I*J, map Int32 arguments onto an Int32 result.
           I/J returns a Num.
           I//J is the Smalltalk integer division operator, returns an integer.
         The result is undefined if the result doesn't fit in an Int32.
       * In Curv, the result on over/underflow of integer arithmetic is a float.
         This is a fundmentally more accurate result than mod 2^32 arithmetic.
         If one of these out-of-range float results is assigned to an Int32
         variable, you will get an error showing the actual numeric value that
         could not be represented.

Typed Variables
---------------
In the code generated by SubCurv, each mutable variable has a type,
and assignments are restricted by the variable's type.
By default, a type is inferred from the variable's initial value.
 * Not a singleton type, though. Only an SC_Type, which is a subset of the
   possible type values discussed in this document.

Reactive Type Inference
-----------------------
Reactive values have types. Each primitive operation on reactive values
infers a result type from the argument types. Types are sets, there is a
lattice of types with a top and bottom. This is a "soft typing" system.
The goal is not to report type errors, but to provide extra information to
the partial evaluator and make it more powerful.

A type that is *just* a predicate function has no structure that tells us
how it relates to other types in the lattice. So perhaps a type is not a
predicate, but we provide idioms for defining types using predicates.

What extra structure is needed? A Prime type that contains prime integers
is a subset of Num. Perhaps we represent it using a predicate function,
plus upper and lower bounds within the type lattice. The upper bound is Num.
When would we have a useful lower bound on a type?

Older Ideas
===========
Syntax
------
Given a type Foo (using straw-man syntax), here are possible syntaxes.

is_foo X, make_foo X
 + Compatible with is_shape, make_shape. It's obvious how to define a user
   defined type (it is a pair of functions).
 - Given one function, you can't derive the other.

Goal: given a single name, 'Foo', you can derive all of the operations on Foo.
In some cases, 'Foo' is an Algebra (a record).

is Foo X, make Foo X

Is Foo a callable value? If so, does calling Foo give you a predicate or a
constructor?
 * predicate: All types have a predicate, but not all types have a constructor.
   If we choose 'predicate', then an ordinary predicate function is also a type.
 * constructor: This allows constructors from the Abstract Value proposal to
   be classified as types.

Foo is a predicate, some operation on Foo is a constructor (eg, make Foo).
    Not compatible with Abstract Value constructors.
    Not in the spirit of "types are not predicates".

Foo is a constructor, Foo? is a predicate
    We can make it convenient to invoke or define the predicate of Foo.
    'Foo? x' is sugar for 'Foo.predicate x'
    'Foo? x = x >= 0' is sugar for 'Foo = {predicate x = x >= 0}`
    Or maybe we provide idioms for constructing predicates that contain
    extra type structure so we know how the predicate relates to other types.
