Simple Data Abstraction
=======================
This is a simple subset of Algebraic Data Abstraction, without theories
or generic programming or runtime polymorphism. The goal is to support
user-defined data types (UDTs), which can't be confused with built-in types,
and to support an abstract interface to a user defined type using a fully
functional interface (all operations on the data type are functions).

UDT Requirements:
* constructor functions
* instances print as constructor expressions
* constructor expressions can be used as patterns
* index values as selectors
* equality and referential transparency

Other considerations:
* Backwards compatibility with POD based functional interfaces?
  This is possible using a `match` with cases for the old POD values
  and the new UDT values. No special features required.
  So it's just a question of how convenient this is (and how important it is).
* Metaprogramming: construct a UDT algorithmically?

An operation on a UDT is a function:
* A constructor (maps arguments to an instance).
* A combinator (maps one or more instances to another instance).
* An observer (maps an instance to a noninstance).
* A selector (an observer that maps an instance to a data structure element,
  and can be used for updating an instance; aka an index or lens).

By convention, the operations on a UDT are packaged in a module named after
the UDT.

Data Types
----------
Every boxed Curv value contains a type tag, which is used for dynamic
dispatching. This is a statement about the Curv VM.

I've considered two models:
* All type tags are disjoint. This is similar to Scheme, where primitive types
  are disjoint.
* Type tags form a hierarchy. This is similar to Julia.
I prefer to keep things simple.

A value's type tag is determined when it is constructed. In fact, I believe
that it is uniquely determined by the value's constructor (and not by any
constructor arguments).

A simple data constructor has a unique type tag associated with it.

Each type tag has an associated Type value -- all of the values with that tag
belong to the associated type. Not all Types have an associated tag: those
that do are called "data types".

Primitive types (which are not constructed using 'data' definitions) also
have tags and data types. For example, `Num` is a data type.

Data types are used by theories for efficient dynamic dispatch of overloaded
operations. A theory used for dynamic dispatch may require its types to be
data types.

If we use the simple design, where all data types are disjoint, then every
value has a unique data type associated with it. This means, in theory, we
can provide an operation that returns a value's data type. I don't have a
use for this. But, Python has a type(x) function that seems to implement this.
In Julia, only the leaf nodes of the tag tree can be associated with objects,
so in this scheme also, a value has a unique data type which is either the 
same as or disjoint from the data types of other values.

Simple Data Constructors
------------------------
A data constructor is defined like this:
    data CtorName ArgType0 ArgType1 ... -- 0 or more arg types

This is the simplest design that meets the needs of the shape library.
One use case for data constructors is to add new constructors to an existing
Theory, such as the Shape theory. Data constructors may have zero or more
curried arguments, because so do shape constructors:
    everything
    cube 10
    rotate (45*deg) cube

Sum types could be defined like this:
    data MySumType (Enum [#foo, #bar, baz: Num])

A data constructor value supports multiple protocols:
* is a constructor function (if the constructor has at least one argument).
* is a data value (if the constructor has zero arguments).
* is a type for classifying instances of the data constructor.

Problem: this design suggests that Type is a theory, which is extended by
defining new data constructors. Eg, 'data MyType' could be used to create a
new niladic type constructor. Except that MyType is already a type used to
classify its sole instance, which is the value MyType. So there is a conflict.

Strawman #H: Constructors
--------------------------
Something like Haskell data type declarations would be okay.
    data CtorName ArgType0 ArgType1 ... -- 0 or more arg types
    data TypeName = ctorspec1 | ctorspec2 | ...

This is combined with the Types proposal.
Each CtorName behaves as a type name.

Strawman #A: Constructors
--------------------------
Only this:
    data CtorName ArgType
Ultimate simplicity, and is a subset of #H. Could be extended to #H later.

If you are modelling your data using POD, then algebraic type instances
look like this:
    #foo
    bar: 1

In proposal #A, you lift this to an abstract type by adding a single
constructor name that takes symbols and arrows as an argument, like this:
    data Dat Enum[#foo, bar: Num]
So now the instances look like this:
    Dat #foo
    Dat (bar: 1)
(Unlike proposal #H, which would use this:)
    Foo
    Bar 1

Could you make the new interface fully backward compatible with POD?
 * Sure, nothing special required. Just use a `match` with cases for
   the new UDT and the old POD.
 * Use a transform pattern in operations with a UDT argument, like this:
      f (x <: CtorName) = ...
   And we specify that CtorName is an idempotent function.

   ??? But the usual Haskell idiom is pattern matching on the ctor, like this:
      f (CtorName x) = ...

Metaprogramming: This proposal allows UDTs to be constructed algorithmically,
since all the complexity is in the ArgType, which is a runtime value.

Hidden Representation
---------------------
In some cases we wish the true representation of a UDT value to be different
from the constructor argument (that is printed when the value is printed,
and that is matched on by constructor patterns).

For example, I want this for the Colour type. External: sRGB, internal:
linear RGB.

This feature could be handled using a Theory, similar to how Haskell has
a type class Show and Rust has a trait. This Theory provides a bidirectional
mapping between the internal representation and the constructor argument.

Equality and Referential Transparency
-------------------------------------
Given two UDT instances that print the same (as textually identical
constructor expressions `F x`), these two values are equal if the F's
(the constructors) are equal and the x's (the constructor arguments) are equal.
[In other words, I am not at present guaranteeing an isomorphism between
equality of value and equality of printed representation. Maybe later.]

UDT constructors are labelled values, so the issue of constructor equality
is punted to the Labelled Value proposal.

Under what circumstances are two identical definitions of the same UDT
equivalent? I want Curv expressions to be referentially transparent.
So consider two module expressions containing identical UDT definitions.
The answer may involve Merkel trees. See Labelled Values for details.

Selectors
---------
Index values for a UDT.
