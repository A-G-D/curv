Typed arrays provide efficient representations for large uniform arrays.

Examples:
* strings (of characters), possibly with UTF8 encoding.
* image: a 2D array of Colour, where Colour may have a 24 bit representation,
  or a Colour is three 32 bit floats (both reps are available on GPUs).
* triangle meshes (which contain arrays of 32 bit natural numbers, and
  arrays of 32 bit floats).

Two approaches to typed arrays.

1. Explicit. We provide explicit constructors for typed arrays.
   The dynamic type of a typed array includes its element type.
   There are multiple distinct empty lists, one for each element type.

   The amend and concat operations on typed arrays are restricted: the
   element type of the result must be preserved.
   Binary concat requires both argument arrays to have the same element type.
   The concat monoid doesn't know what to return for `concat[]`, unless:
    * An element type is passed as an extra argument.
    * The element type of the argument determines the element type of the
      result: concat of an empty list returns the argument.

2. Implicit. There is only one list type and one list constructor.
   There is only one empty list.

   We use efficient compact representations for uniform arrays,
   but we don't restrict the amend and concat operations, which means a
   uniform array can be transformed into a general array via amend or concat.
