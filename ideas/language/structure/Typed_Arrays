Typed arrays provide efficient representations for large uniform arrays.
Typed arrays may also provide semantic benefits.

Examples:
* strings (of characters), possibly with UTF8 encoding.
* image: a 2D array of Colour, where Colour may have a 24 bit representation,
  or a Colour is three 32 bit floats (both reps are available on GPUs).
* triangle meshes (which contain arrays of 32 bit natural numbers, and
  arrays of 32 bit floats).

"Scalar types", corresponding to examples:
 * Char : ASCII character or Unicode code point
 * RGB24 : 24 bit RGB colour
 * Float32
 * Nat32

Requirements
------------
Typed arrays have special representations for scalars, more compact than
general boxed scalars. There may also be compression schemes, eg UTF-8
or image compression or VDB.

There are traditional operations/constructors for creating typed arrays.
Eg, UTF-8 string literals "abc", or `file "foo.png"`.

Support a general set of functional operations over typed arrays:
 * concat
 * amend
 * map from a typed array
 * map to a typed array
 * generic list comprehensions

Identity of Indiscernables
--------------------------
Under this principle, the number 42 is the same value regardless of
whether it is represented as a boxed Num, or as a 32 bit nat, or as a
32 bit float. The alternative is to have many different values, of
different types, all of which represent 42. I have avoided this so far,
because I want to avoid incidental complexity.

The "scalar types" Float32 and Nat32 can be interpreted as predicates on
the set of all values, or as value sets. Nat32 is a subset of Num.
Less obviously, Float32 could also be interpreted as a subset of Num,
if by Num we mean 64 bit floats.

If we apply the same principle to lists and arrays, then there is only
one empty list `[]`, instead of many empty lists with different element types.
(I didn't follow this principle perfectly: instead of a Character type,
Curv has strings and lists, so "" and [] are distinct.)

Two Approaches to Efficient Representation of Large Uniform Arrays
------------------------------------------------------------------
### 1. Explicit (typed arrays)
We provide explicit constructors for typed arrays.
The dynamic type of a typed array includes its element type.
There are multiple distinct empty lists, one for each element type.

The amend and concat operations on typed arrays are restricted: the
element type of the result must be preserved.
Binary concat requires both argument arrays to have the same element type.
The concat monoid doesn't know what to return for `concat[]`, unless:
 * An element type is passed as an extra argument.
 * The element type of the argument determines the element type of the
   result: concat of an empty list returns the argument.

### 2. Implicit
There is only one list type and one list constructor.
There is only one empty list.

Internally, we use efficient compact representations for uniform arrays.
Certain operations generate these compact representations.
Amend and concat represent these compact representations, if they can.

We don't restrict the amend and concat operations, which means a
uniform array can be transformed into a general array via amend or concat.

A string literal "abc" is sugar for a list constructor [#\a, #\b, #\c].
So we need a character type.

Generic List Comprehensions
---------------------------
How does this work?

Explicit:
   An explicit array type must be used to specify the type of value
   generated by the list comprehension. An error is reported if any of the
   scalars are the wrong type for the array type.
      'array type'[generators...]

   Benefits: document and enforce assumptions within the program.

Implicit:
   Each array type is characterized by a distinct scalar type.
   An ordinary list comprehension generates a sequence of values possessing
   this scalar type. We examine the scalars being generated by a comprehension,
   and if they have a type for which there is a corresponding special array
   type, then we attempt to construct an instance of that array type. If the
   initial run of scalars of the same type is followed by a scalar of a
   different type, we abandon this attempt and construct a generic list.

   Benefits:
    * No ceremony.
    * Less accidental complexity: identity of indiscernables.
    * Less complex generic programming.

   What about those "distinct scalar types"?
    * Char : ASCII character or Unicode code point
    * RGB24 : 24 bit RGB colour
    * Float32
    * Nat32

Semantics of Typed Arrays
-------------------------

Relation to Data Abstraction
----------------------------
