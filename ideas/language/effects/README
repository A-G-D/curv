Pure Functional Effects in Curv: Effects without the Side Effects
=================================================================

Relevant goals for the Curv language:
* A DSL for describing any kind of geometric shape.
* A low level API that lets new shape operators be defined in Curv.
* A REPL that uses Curv as the command language.
* The REPL has commands for modifying UI state. Any state change that can be
  performed using the GUI can also be performed in the REPL.
  This includes modifying persistent source code in the unified GUI.

With these goals, Curv must evolve to be more general purpose.
We already have statements and actions in the language; they have multiple uses.
How do you abstract over statements, or define new actions from within Curv?
How do you abstract over mutable variables?

Functional Effects
------------------
Curv is a pure functional language. There are no side effects.
We need a pure functional semantic model of actions suitable for Curv,
analogous to the role of monads in Haskell.

With side effects in an imperative language, an imperative procedure call can
do absolutely anything to the global state. It is an unsafe programming model:
side effects are not under the control of the caller. This model of computing
is the primary source of security holes in the current era. We are trying to
patch this problem using sandboxes, and capability based security, where the
caller of a function determines what state can be changed. In a capability
system, you can't change state unless you have been passed a capability that
gives you that power.

Pure functional programming is the logical end point of consistently applying
the principles of capability based security.

An action is a function that is passed a 'capability' (a description of some
external state that can be queried, modified, interacted with). The action
does its thing, returning a modified form of the capability that describes the
modified state.

In the general case of functional i/o, you need a mechanism to prevent certain
types of capabilities from being counterfeited or cloned, like the 'World'
in Haskell.

Procedures
----------
Curv makes a syntactic distinction between statements and expressions,
otherwise the REPL doesn't work. The REPL interprets an expression by
printing a value, and interprets a statement by changing some state.
Similarly, expressions and statements are treated differently in a list
constructor.

Statements are constructed using primitive operators and metafunctions.

We need some form of procedure value, where a procedure is a parameterized
abstraction over a statement. Rationale:
  * You can abstract a statement with a let block.
    According to the principle of equivalence, this means you should also be
    able to abstract these phrases using functions.
  * It should be possible to replace any use of `for` with tail recursion.
  * It should be possible to use `match` in any context where `if` is legal.
    Eg, in a list comprehension.
  * Once I have an interactive debugger, and a rich set of actions for
    controlling the debugger, then procedures are used as debugger scripts.
  * print, error, warning, assert become values.
  * Maybe I get rid of metafunctions, and all of the metafunction bindings
    in the standard prelude become values or keywords. Now the standard
    prelude can be represented as a record value.
I want procedures to support abstraction over a mutable local variable
(by-reference parameters).

Effect Values
-------------
This is a specific design where a procedure is a function that maps an argument
onto an Effect value.

An Effect is a function that maps a state value onto an updated state value.
Usually this is a "linear function" that is implemented by mutating the
state value object without copying it.

The empty effect (does nothing) is represented by the identity function.

A debug effect like `print "abc"` is represented by an identity function that
causes a debug side effect (eg, print to the debug console). Debug effects
are the only example of true side effects in Curv.

An action containing assignment statements is an effect that maps an
environment record (with fields corresponding to local variables) onto
another environment record. For composability with other effect types,
the effect argument is a record containing an 'env' field that denotes the
environment.

A 'value generator' effect can be modelled as a function that maps
a record containing a 'list' field to another record with the same
structure. Zero or more elements are appended to the list by the effect.
 * Maybe we provide a more abstract effect interface, so that the client
   can consume the value sequence generated by the value generators and
   process the sequence in an arbitrary way, without putting them all into
   a list first.
 * Eg, there is a 'seq' field containing seq.val and seq.f.
   The value E generated by the generator is processed by executing
        arg.seq.val := arg.seq.f[arg.seq.val, E]

Effects are composed using the ';' operator. (There is a famous blog post
titled "Monads are not composable". Arbitrary effects *are* composable, so
what's the practical advantage?)

Statement Syntax
----------------
The Effects proposal seems to replace statement syntax with effect expressions.
The ';' operator seems to be an extended form of function composition that
also understands local definitions.
 * This is elegant, because you can abstract effect expressions using any of
   the abstraction mechanisms that work on expressions.
 * This is a problem, because the current syntax for REPL commands and elements
   of list constructors relies on the syntactic difference between statements
   and expressions.

If I keep the Effects proposal, because of its expressiveness, then I could
use `!effect` as statement syntax in the REPL.

What is the syntax for a procedure call?
 1. Juxtaposition, overloaded with function call. The distinction between
    expression and statement happens at run time. `print` and `warning`
    become values without a syntax change.
     * Doesn't compose with 'match'. The problem is 'match[]': function or
       procedure?
 2. A specialized operator, like 'proc!arg'.
     * Composes with match.
 3. A procedure is a function that returns an effect value.
    A procedure call 'P x' returns an effect value, which is converted to
    a statement using '!eff', so the syntax is '!P x'.
     * Composes nicely with match (no change required).

rproc and lproc
---------------
An rproc literal is a function literal where the body is a statement.
The purpose is to encapsulate value and field generator effects.

An lproc is a kind of procedure that takes a single locative as a
by-reference argument. The actual argument is any lvalue that can appear
on the left side of an := statement. The formal parameter is an lvalue pattern:
either an identifier, or the kind of pattern that can appear on the left
side of an := statement (eg, [lval1,lval2] or {id1,id2}). The body is a
statement in which the formal parameters are lvalues.

You can pass multiple lvalue arguments by grouping them in a record pattern.
You can use Currying to mix value and lvalue arguments.

An lproc that contains no generator statements can be invoked using a function
call expression. The argument is bound to a local variable whose contents are
then transformed using the lproc body. The final contents of the local variable
are yielded as the result.

Construction:
    lproc <lpattern> <statement>
Calling an lproc:
    <statement> ::= <lvalue> ! <lproc-expr>
                  | <lvalue> ! <lproc-expr> ! <lproc-expr> ...

The most natural implementation will allow lproc to contain value
generators and field generators. An lfunc that generates values and has
no other effects could have a [] pattern as parameter and be invoked using
a [] pattern as argument. So this is a reasonably failful reproduction of
the semantics of imperative procedures. Just call it a 'proc'.

This doesn't have the generality of monads, or of what I was loosely
envisioning for the Effects proposal, but it is easy to implement in the
current framework and solves most of my current problems.

Does it compose with 'match'? Not really, no. It doesn't make a lot of sense
and isn't needed. A procedure with 'by value' arguments is constructed as a
curried function that returns a procedure.

Call-By-Reference
-----------------
Requirement: a kind of procedure that takes one or more locatives as
by-reference arguments, then reads and writes these locatives using
statement syntax (as if the locative parameters were local variables
defined using 'local').

Let's say that we use named arguments: the model is that the procedure
argument is a record.

Semantically, a procedure like this is a mapping from a record to another
record with the same fields.

-------------------------------------------------------------------------
::::::::::::::
Effects
::::::::::::::
A 'Procedure' is a function that returns an 'Action' when called.
An 'Action' is a value that describes a set of 'Effects',
which are changes to state within some domain.

At some point, the Action value needs to be 'executed' in some domain
in order to bring about the state changes that it describes.
But that's an implementation detail.

This is a pure functional system that describes Effects declaratively.
It is an alternative to imperative procedures, which cause side effects
when called. In Curv, there are no side effects. There are Effects,
but they don't occur "on the side".

In an imperative language, any function can have arbitrary side effects,
modifying state anywhere in the program, with no limitations.
This is an inherently unsafe programming model.

In Curv, an Action is limited to causing state changes within a specific
domain, which is controlled by the caller. Any attempt to perform state
changes that are not supported by the domain will cause an error.
This is a safe programming model.
::::::::::::::
Lens
::::::::::::::
How this relates to the Lens feature.

To implement lenses efficiently, we need the ability to define ordinary
functions that take a large data structure as an argument, efficiently
update the structure without copying it, then return the modified copy
as a result. (Let's call these "linear functions".) So let's assume that
feature is available.

A procedure can be modelled as a linear function that takes the "environment"
as an argument, modifies it and returns a new environment. A procedure is just
an ordinary function. So it needs to be called in a special way to write
imperative code.

Also, a Lens can be used to construct a Procedure.
    put lens new_elem_val
returns a procedure.

Consider the following contexts for procedure calls:
 * top level of a REPL command
 * an action in a do clause
 * an action in a comprehension

We could put the environment into a mutable variable called `env`, whose
binding changes based on the context, and use the syntax
    env := P env
to call a procedure.

Here's a nicer syntax (these are actions):
    var!P   --  same as var := P var
    !P      --  same as env!P

If I provide an operator for controlling the binding for 'env' that gets
passed into a comprehension, then we have the equivalent of monads and do
expressions in Haskell.

How do the existing "debug" actions fit into this framework?
    print
    warning
    error
    assert
These are intended to be pervasive, available everywhere.
They modify the shared mutable state of the debugger, which is the only
example of shared mutable state supported by Curv.

A debug action is a procedure that, functionally, is an identity function,
but which modifies the debug state as a side effect. They are invoked
using the ! operator:
    !print "hello world"
    !assert(x == 0)
Because they are identity functions, they can be inserted into a pipeline:
    whatever >> print "hello world" >> dosomething

The unary ! operator is a replacement for the existing `exec` operator.
The 'identity function with side effects' semantics are closely aligned to
the actual C++ implementation. This is brilliant, I should just implement this
immediately, without waiting for the entire effects system.

Procedures
----------
* Make it possible to replace any use of `for` with tail recursion.
* Make it possible to use `match` in any context where `if` is legal.
  Eg, in a list comprehension.

A partial solution for `match` might look like this:
    !a >> match[pat1->proc1, pat2->proc2, ...]

The original roadblock was my perception that we must construct 'procedure'
closures that capture mutable variables from their environment. Which is
forbidden by design.

But this new perspective provides a way forward. A procedure takes the local
environment of in-scope mutable variables as a record argument, mutates
the record and returns the updated environment.

So a procedure literal is something like 'proc(statement_list)'.

Taking this further, a procedure literal is '[| stmt1; stmt2; ... |]'.
The while statement becomes a combinator.
    !WHILE condition DO [| statements |]

Taking this further, statements are functions from an environment to an
environment, and the ';' operator is function composition.
::::::::::::::
Monads
::::::::::::::
::::::::::::::
Procedures
::::::::::::::
A procedure is a lambda-abstraction of a statement.

Benefits:
* Make it possible to replace any use of `for` with tail recursion.
* Make it possible to use `match` in any context where `if` is legal.
  Eg, in a list comprehension.
* Once I have an interactive debugger, and a rich set of actions for
  controlling the debugger, then procedures are used as debugger scripts.
* print, error, warning, assert become values.
* Another step in making it easier to port imperative code?

Challenge: Mutable Variables
----------------------------
I just redesigned Curv so that mutable variables, the assignment statement,
and the while statement are fully supported and general within the imperative
sublanguage.

Those 'benefits' seem to require that procedures will capture references to
mutable variables. Which would violate the pure functional semantics of Curv,
if these procedures are first class values. It introduces shared mutable state.
This isn't going to happen.

The use cases for the imperative sublanguage are:
* Imperative algorithms using mutable variables & while statements.
  * To use pattern matching conditional statements in this code, we can't
    use the `match` function, we need a pattern-matching switch statement.
  * To use tail recursion, you have to convert the code to a functional form
    that uses pure functions instead of mutable variables.
* List comprehensions.
* Debugging and unit testing.

The latter two use cases could benefit from a restricted kind of procedure
that can't capture non-local mutable variable references. Further analysis
would probably reveal an underlying monadic structure to specialized domains
such as list comprehensions and debugger control.

The question is: are these use cases enough to justify procedures?
Maybe new monadic structures will arise in the future that will create more
of a need for this feature?

Challenge: Expressions vs Statements
------------------------------------
Originally, every Operation is either an expression or statement, determined
by syntax, meaning it can be determined at compile time.

A function/procedure call can be ambiguous: it can be either an expression or a
statement, depending on argument values. An if-else phrase can be either an
expression or a statement, ditto a call to error, so user-defined functions/
procedures can have the same property.

If we embrace this flexibility, then higher order functions
can act as either functions or procedures, depending on argument values.
Function calls can't be classified as expressions/statements until runtime.
Does this cause technical problems?
* No problem for the REPL.
* Future IR/executable format: no problem. Operations will be compiled into
  either expression or statement nodes (corresponding to Operation::eval()
  and Operation::exec()), based on syntactic context.
* But with segregated function/procedure call, we can do more analysis.
  We can distinguish expressions from value generators in a list constructor.
  Because we know that 'f x' is an expression, not a procedure call:
  * The partial evaluator can replace '(f x, a)[1]' with 'a'.
  * We can produce better At_Index error messages. Instead of:
        ERROR: at index [1]: true is not a number
        1|       [f x,true,3]
                 ^^^^^^^^^^^^
    we can say:
        ERROR: true is not a number
        1|       [f x,true,3]
                      ^^^^
  These benefits could be mostly restored with better compile time analysis:
  most functions could be classified as true functions at compile time just
  by looking at the syntax tree.

Does this flexibility cause usability problems?
Benefits are:
* More expressive power. 'error' is a value.
* Only one syntax for functions and for function call. Splitting these syntaxes
  introduces unfamiliar concepts not found in other languages.

Philosophical Challenge: Two ways to do it.
-------------------------------------------
Under this proposal, there are two ways for a function to return a sequence
of values: either by returning a single list value, like this:
    iota n = 1..n;
or by generating a sequence of values, like this:
    gen_iota n = ...(1..n); /* or */
    gen_iota n = for (i in 1..n) i;

During the pre-Curv design process (OpenSCAD2), I explicitly did not want to
support two ways for a function to return a sequence. I didn't want to
encourage fragmentation of library APIs, where you have to know which of the
two protocols was being used, and then possibly write glue to convert between
the two protocols, either '...iota n' or '[gen_iota n]'.

So now I have generators, which are phrases that generate a sequence of values.
Consider generators in Icon, or generators in Python.
I'd rather have lazy lists (like Haskell) instead.

There is no way to directly iterate over a generator. You have to
capture the output in a list or record first. Does this mitigate the problem,
by deterring the use of generator procedures in libraries?

"If you only have a hammer, then every problem looks like a nail."
Value generators will have a performance advantage over lists, in the
case where you are incrementally accumulating a list of values, eg 1 per
function call, due to the O(N) cost of list concatenation.

The Jq proposal, to extend Curv to embrace the features of Jq, actually
requires the use of value generator procedures (as a supertype of functions).
Haskell style lazy lists do not have the required semantic properties.
We need the concept of a flat stream of values, where embedding one stream in
another results in automatic flattening, and not a tree structure.

Proposal: Procedure Call Syntax
-------------------------------
Maybe the syntaxes for procedure and function call should be segregated.

Benefits:
* It can be helpful for human readability. It makes the procedural subset of
  Curv stand out syntactically from functional code.
* The compiler can distinguish expressions from statements at compile time.
  We can distinguish expressions from value generators in a list constructor.
  Because we know that 'f x' is an expression, not a procedure call:
  * The partial evaluator can replace '(f x, a)[1]' with 'a'.
  * We can produce better At_Index error messages. Instead of:
        ERROR: at index [1]: true is not a number
        1|       [f x,true,3]
                 ^^^^^^^^^^^^
    we can say:
        ERROR: true is not a number
        1|       [f x,true,3]
                      ^^^^
* After calling Program::compile(), you can query the Program to determine
  if you have compiled an expression, statement or definition, and then call
  Value eval(), exec(Consumer&) or Shared<Record> define()
  to execute each type of program.
  * Right now, the REPL doesn't distinguish between 'cube' and '...[cube]',
    because it can't distinguish an expression from a statement. No big deal,
    but now it can make that distinction.
* The proposal for compiling Curv into CPS instructions benefits if we can
  generate different code for expressions and statements.

A proposed syntax for procedure call:
  postfix ::= postfix '!'   -- this is a procedure reference, not an expression
  procedure call syntaxes:
    procedure_ref primary
    expression >> procedure_ref
    procedure_ref << expression
For example,
  print! "hello world"
  "hello world" >> print!
Curried procedure call is a bit odd:
  myproc a b! c

If you call a procedure using function call syntax, or call a function using
procedure call syntax, you get an error. So procedure and function values must
be internally distinguished in some way.
* Maybe not. This seemingly conflicts with the doctrine that Expression
  is a subtype of Value_Generator. So is Function a subtype of Procedure?
* In the discussion of `jq`, it's useful to consider Function to be a subtype
  of Value Generator Procedure.
* So this would mean, calling a function with procedure call syntax results
  in a value generator phrase. Which might cause an error if the context
  doesn't allow this. But it would be legal in a list constructor.

* `print`, `warning`, `assert` are procedure values.
* As a special case, `error` is both a procedure and a function.

Two type predicates: `is_fun` and `is_proc`.

Libcurv has a "generalized function" class with both a call() method
(for function call) and an exec() method (for procedure call).

Lambda expressions and functor definitions need not have segregated syntax
for procedures and functions. The compiler doesn't need it, it would only be
for the benefit of human readers, if there is a benefit. Syntax could be:
    param => statement
    param1 -> param2 -> finalparam => statement
    identifier! param = statement;
    identifier param1 param2! finalparam = statement;
If a procedure body is an expression, it's treated as a value generator.
Without this syntax, you would use `x->...[x]` for a procedure that generates x.
With this syntax, you could use `x=>x`.

Can a Curv source file contain a statement?
We could use `file! filename` to execute such a program.

A procedure cannot reassign a nonlocal sequential variable
----------------------------------------------------------
`x := x + 1` cannot be the body of a procedure, because of restrictions
on the scope of sequential variables.
* The OpenSCAD 'do' proposal had procedures with by-reference 'var' parameters.
  If 'x' was a 'var' parameter then this would be legal.
  However, this idea doesn't allow us to simply evaluate procedure argument
  expressions to pure values.
* Not a problem. The important use case is action procedures.
  In that case, you write a function that invokes actions as side effects,
  using `do`, and you just return the results from the function call.

Proposal: Unified Function and Procedure Values
-----------------------------------------------
* No new syntax.
* print, warning, assert become values with no syntax change.
* error is a value, only one syntax to invoke it.

When a function is called, it optionally causes side effects, it optionally
returns a value, and it optionally generates a sequence of elements or fields.
The context of a function call determines which of these behaviours are legal.

Since we distinguish returning a value from generating a single value,
and since there is no `!` marker to distinguish procedure from function calls,
I want the REPL to distinguish generated from returned values in the output
of a command. A `>` prefix for generated values.

Instead of Program::eval() and ::exec(), we have ::run().

Proposal: Procedures are not Values
-----------------------------------

Old Thoughts about Procedures
=============================
Procedures (Functions returning actions or generators):
* A statement is an action, value generator, or field generator.
  A procedure is a function that abstracts over a statement.
  Procedures are values, but can only be invoked in a statement context.
* Pragmatic justification:
  * It should be possible to replace any use of `for` with tail recursion.
    This requires procedures.
  * It should be possible to use `match` in any context where `if` is legal.
    Eg, in a list comprehension. This requires procedures.
  * Once I have an interactive debugger, and a rich set of actions for
    controlling the debugger, then procedures are used as debugger scripts.
  * print, error, warning, assert become values.
  * Maybe I get rid of metafunctions, and all of the metafunction bindings
    in the standard prelude become values or keywords. Now the standard
    prelude can be represented as a record value.
* Theoretical justification:
  * You can abstract a statement with a let block.
    According to the principle of equivalence, this means you should also be
    able to abstract these phrases using functions.
  * Suppose I use the Haskell 'monad' trick to implement phrase abstraction.
    Then a statement is a function value (with a weird argument type, of a
    special type of value that can't be counterfeited, like the IO type in
    Haskell). A procedure would then also be a value. This
    demonstrates that procedures can be made theoretically sound.
* Challenges:
  * Can I invoke an arbitrary procedure from the command line?
  * `...` is ambiguous in a weak context. So I can't mark a procedure as being
    an action, element gen or field gen abstraction at value construction time:
    it could be argument dependent, as in `spread x = ... x`.
    So procedure calls are ambiguous in a weak context.
    Does it help if I split `...` into 2 operators?
  * `seq(p1,p2) = (p1();p2())`. Another polymorphic procedure. Since `if`, `for`
    and `;` are polymorphic operations on statements, this naturally leads to
    user defined polymorphic procedures.
  * By creating a set of higher order procedures (combinators), you could write
    procedures whose bodies look like expressions: no syntactic clue that they
    are procedures. A function can be polymorphic across the expression and
    statement worlds. The Haskell Monad argument justifies this as meaningful.
  * Right now, [f(x)] compiles into code that evaluates f(x) as an expression.
    A user can tell by inspection that this is a 1-element list. But no more.
    We need to compile into less efficient code (in the general case), and do
    more work to identify the efficient case.

What is `x := x + 1`? Can this be the body of a function?
* Ugh. Sometimes the drive towards full expressive power creates monsters.
  Eg, `call/cc`: generalized goto labels as first class values. Leads to code
  that is nigh impossible to understand.
* Don't be misled. From a monad perspective, `x:=x+1` is a pure function that
  transforms a state value to a state value. This state value is some
  abstraction of the scope that variable `x` is defined in.
  * The state value could be a totally locked down, non-counterfeitable
    abstraction of the frame containing the slot for `x`.
    Maybe each frame has a signature, and `x:=x+1` checks that its state
    value is a frame with the correct signature.
  * The state value could be a record containing the field `x`.
    And there's a bunch of research needed to flesh this out and make it
    efficiently compilable.
* The OpenSCAD `do` proposal had procedures with reference (var) parameters.
  This is more actually useful than the ability to mutate non-local variables.
* Maybe mutable variables are deliberately limited and deprecated.
  Use functional style if you want unconstrained abstraction.
* A procedure cannot reassign a nonlocal sequential variable.
  Use a function instead: `(V1, V2) := F(V1,V2,0);`

I think this is technically achievable.
But it's a can of worms with limited utility.
Consider defining a subset of this that provides the greatest benefit,
to limit the implementation and design cost.
Not for MVP.
