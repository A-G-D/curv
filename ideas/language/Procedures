A procedure is a lambda-abstraction of a statement.

Benefits:
* Make it possible to replace any use of `for` with tail recursion.
* Make it possible to use `match` in any context where `if` is legal.
  Eg, in a list comprehension.
* Once I have an interactive debugger, and a rich set of actions for
  controlling the debugger, then procedures are used as debugger scripts.
* Another step in making it easier to port imperative code.

Challenge: the REPL.
It ought to be possible to call any procedure or function from the command line
and see what it does.
* But right now, I analyze a command line to a Definition or an Operation.
  For operations, I call the generate method, which fails for a field generator.
  Generate works for expressions, actions and element generators.
* Unify field generators and element generators into just 'generators', which
  generate a sequence of values. Add 'field' values, constructed using id:expr.
  Operation::generate() takes a Consumer as an argument, and Consumer::add()
  is a virtual function that consumes either general values, or field values.
  * A record is in some ways like a list of field values.
    I can't take that metaphor very far, because r[i] invokes r.call[i],
    and thus can't be used to fetch the i'th field from a record.
    Maybe 'fields R' converts a record to a list of field values,
    and 'keys R' extracts just the keys from the fields.
  * The `...` operator treats a record as a list of fields.
  * Perhaps the `for` operator should iterate over the fields in a record.

Proposal: Segregated Function and Procedure Values
--------------------------------------------------
In this proposal, we will segregate functions and procedures.
Procedural values are not function values (is_fun and is_proc are disjoint).
A procedural literal is syntactically not a function literal.
A procedure call is syntactically not a function call.

The rationale for segregation is that it's a conservative extension that
doesn't change the nature of function values and function calls, and doesn't
add performance overhead or cause semantic changes to those concepts.

Procedure literal:
    parameter => statement
A statement is the usual: an action, element generator, or field generator.
An expression in this context is treated as an element generator.

Curried procedure:
    param1 -> param2 -> finalparam => statement

Procedure call:
    'exec' procedure-expr argument-expr

A procedure cannot reassign a nonlocal sequential variable.
`x := x + 1` cannot be the body of a procedure, because of restrictions
on the scope of sequential variables.
* The OpenSCAD 'do' proposal had procedures with by-reference 'var' parameters.
  If 'x' was a 'var' parameter then this would be legal.
  However, this idea doesn't allow us to simply evaluate procedure argument
  expressions to pure values.

Benefit?
* print, warning, assert become values. Some metafunctions remain.
  Erp, except that you write 'print x' and not 'exec print x'.

The body of a procedure is a 'weak statement context'. When a procedure value
is constructed, we don't know if the procedure will be called from an action,
list constructor, or record constructor context. And we can't necessarily
determine the 'kind' of a procedure body during procedure construction.
So, a procedure object has 'exec', 'bind' and 'generate' methods,
in parallel with the 'call' method of a function object.

Proposal: Unified Function and Procedure Values
-----------------------------------------------
* No new syntax.
* A function object has call, exec, bind and generate methods.
* print, warning, assert and error become values.

REPL:
It ought to be possible to call any function from the command line and see
what it does.
* But, right now, I analyze a command line to a Definition or an Operation.
  For operations, I call the generate method, which fails for a field generator.
  Generate works for expressions, actions and element generators.
* Unify field generators and element generators into just 'generators', which
  generate a sequence of values. Add 'field' values, constructed using id:expr.
  Operation::generate() takes a Consumer as an argument, and Consumer::add()
  is a virtual function that consumes either general values, or field values.
  * A record is in some ways like a list of field values.
    I can't take that metaphor very far, because r[i] invokes r.call[i],
    and thus can't be used to fetch the i'th field from a record.

A function object has call, exec, and generate methods.
When a function is called, it optionally causes side effects, and it
returns a sequence of zero or more values. When a function is called in
an expression context, it must not generate values, and it must evaluate
an expression in the tail position of its body (which is stricter than the
requirement to generate exactly one value).

This means there are effectively two ways for a function to return a sequence
of values: either by returning a single list value, like this:
    iota n = 1..n;
or by generating a sequence of values, like this:
    gen_iota n = ...(1..n); /* or */
    gen_iota n = for (i in 1..n) i;

During the pre-Curv design process (OpenSCAD2), I explicitly did not want to
support two ways for a function to return a sequence. I didn't want to
encourage fragmentation of library APIs, where you have to know which of the
two protocols was being used, and then possibly write glue to convert between
the two protocols, either '...iota n' or '[gen_iota n]'.

So now I have generators, which are phrases that generate a sequence of values.
Consider generators in Icon, or generators in Python.
I'd rather have lazy lists (like Haskell) instead.

Proposal: Procedures are not Values
-----------------------------------

Old Thoughts about Procedures
=============================
Procedures (Functions returning actions or generators):
* A statement is an action, element generator, or field generator.
  A procedure is a function that abstracts over a statement.
  Procedures are values, but can only be invoked in a statement context.
* Pragmatic justification:
  * It should be possible to replace any use of `for` with tail recursion.
    This requires procedures.
  * It should be possible to use `switch` in any context where `if` is legal.
    Eg, in a list comprehension. This requires procedures.
  * Once I have an interactive debugger, and a rich set of actions for
    controlling the debugger, then procedures are used as debugger scripts.
  * print, error, warning, assert become values.
  * Maybe I get rid of metafunctions, and all of the metafunction bindings
    in the standard prelude become values or keywords. Now the standard
    prelude can be represented as a record value.
* Theoretical justification:
  * You can abstract a statement with a let block.
    According to the principle of equivalence, this means you should also be
    able to abstract these phrases using functions.
  * Suppose I use the Haskell 'monad' trick to implement phrase abstraction.
    Then a statement is a function value (with a weird argument type, of a
    special type of value that can't be counterfeited, like the IO type in
    Haskell). A procedure would then also be a value. This
    demonstrates that procedures can be made theoretically sound.
* Challenges:
  * Can I invoke an arbitrary procedure from the command line?
  * `...` is ambiguous in a weak context. So I can't mark a procedure as being
    an action, element gen or field gen abstraction at value construction time:
    it could be argument dependent, as in `spread x = ... x`.
    So procedure calls are ambiguous in a weak context.
    Does it help if I split `...` into 2 operators?
  * `seq(p1,p2) = (p1();p2())`. Another polymorphic procedure. Since `if`, `for`
    and `;` are polymorphic operations on statements, this naturally leads to
    user defined polymorphic procedures.
  * By creating a set of higher order procedures (combinators), you could write
    procedures whose bodies look like expressions: no syntactic clue that they
    are procedures. A function can be polymorphic across the expression and
    statement worlds. The Haskell Monad argument justifies this as meaningful.
  * Right now, [f(x)] compiles into code that evaluates f(x) as an expression.
    A user can tell by inspection that this is a 1-element list. But no more.
    We need to compile into less efficient code (in the general case), and do
    more work to identify the efficient case.

What is `x := x + 1`? Can this be the body of a function?
* Ugh. Sometimes the drive towards full expressive power creates monsters.
  Eg, `call/cc`: generalized goto labels as first class values. Leads to code
  that is nigh impossible to understand.
* Don't be misled. From a monad perspective, `x:=x+1` is a pure function that
  transforms a state value to a state value. This state value is some
  abstraction of the scope that variable `x` is defined in.
  * The state value could be a totally locked down, non-counterfeitable
    abstraction of the frame containing the slot for `x`.
    Maybe each frame has a signature, and `x:=x+1` checks that its state
    value is a frame with the correct signature.
  * The state value could be a record containing the field `x`.
    And there's a bunch of research needed to flesh this out and make it
    efficiently compilable.
* The OpenSCAD `do` proposal had procedures with reference (var) parameters.
  This is more actually useful than the ability to mutate non-local variables.
* Maybe mutable variables are deliberately limited and deprecated.
  Use functional style if you want unconstrained abstraction.
* A procedure cannot reassign a nonlocal sequential variable.
  Use a function instead: `(V1, V2) := F(V1,V2,0);`

I think this is technically achievable.
But it's a can of worms with limited utility.
Consider defining a subset of this that provides the greatest benefit,
to limit the implementation and design cost.
Not for MVP.
