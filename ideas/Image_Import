Import a 2D image file
======================

Use cases:
* RGB image, which is converted to:
  * a rectangular shape with a colour field
* Monochrome image, which is converted to:
  * an intensity field
  * a distance field
* RGBA is not supported, for now.

Let's focus on RGB images.

File types? Start with PNG.

When we import an image and convert it to a shape, there is no natural way
to determine the pixel size or image size in Curv coordinates. So we need to
use an arbitrary convention, or the user needs to explicitly state the image
size or pixel size.

According to the Package proposal, an image file 'foo.png' is imported using:
  `file "foo.png"` -- old syntax
  `file.foo` -- new syntax
This returns a Curv image value, encoded using the 7 types.

Possible requirements for image values:
* Easy to convert an image to a shape, with minimal syntax.
* Can explicitly specify the pixel or image size in Curv coordinates, when
  converting to a shape.
* Direct access to RGB pixel array, as a rank 5 tensor.

Here is a possible API for image values:
* img {psize: pixel_size} => shape
* img {xsize: image_width} => shape
* img {ysize: image_height} => shape
* img {size: (xd,yd)} => shape
* img.data => RGB pixel array as a rank 5 tensor

Eg, `file.my_icon {ysize: 2}`.

Image Values
------------
curv::Image is what `file "foo.png"` returns.
Other classes: Image_Shape, Image_Data, Image_Data_Row.

Need superclasses for: abstract record, abstract list.

GLSL Code
---------
An image is represented by a uniform variable of type `sampler2D`.
Eg, `uniform sampler2D image1`. If I use the shadertoy naming convention,
the names will be "iChannel$i" for i >= 0.

These samplers are referenced in calls to GLSL texture lookup functions.
    my_vec4 = texture(iChannel0, my_vec2)

The `texture` function requires implicit derivatives. "Non-uniform control flow"
violates the implicit-derivative requirement (and leads to undefined results,
not a compile time error). I don't think this can occur right now in Curv,
but it could be a problem in the future.

The GL compiler will traverse the shape value to generate code.
During this traversal, it produces several outputs:
 * A code string containing the main body of GLSL.
 * An image list, stored in the GL_Compiler.
   Each time an Image is found (that contributes to the final result), it is
   assigned a sequential integer ID and appended to the image list.
 
The Image list is used by:
* The GL compiler (converted to a list of sampler2D declarations, which is
  prepended to the main code body).
* The JIT compiler emits C++ code containing pathnames of images to load
  into memory.
* The Viewer loads each image into the GPU and defines uniform sampler2D
  variables for each image.

Viewer
------
The Viewer must load images into the GPU and make these images available
as sampler uniforms in the fragment shader. The Shape_Program contains the
image array.

Viewer::set_shape(Shape_Program&) must be used to set a new shape.
Get rid of set_frag(). Either set_shape() copies data from the program,
or the program is passed as unique_ptr<Shape_Program>.

Shape_Program shape{program};
b = shape.recognize(value);

Compiler/Evaluator
------------------
During compilation and/or evaluation, we need to construct the image array
and put it somewhere so it can be referenced by the Shape_Program.

Image file references are compile time constants (in the current design).
So, we'll construct the image array at compile time. The Analyzer will store
them in a Program structure accessed from the Environ.

If one program references another using `file`, then there is actually a
tree of Program objects. All of the image files will need to be considated
in the root Program, once the root Program has completed analysis.

`file("image_path.png")` -- or whatever the syntax -- results in a curv::Image
object, which contains the image file pathname, the image data (lazily loaded),
and an ID number, which is filled in by the GL compiler.

Evaluator
---------
We need the ability to evaluate image colour functions in the CPU as well:
* In the interpreter.
* In C++ JIT compiler output. How is the image data referenced?
  * It could be reloaded from the original image files.
  * It could be inserted into the C++ code as C array data.
    This is probably slower.
