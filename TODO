# 0.2: geometry
Extend language to condense/speed up existing geometric operators.
* curried function definition
* vectorized numeric operations (array language)
  * arith ops: + - * / ^
  * builtin: sqrt,abs,max,min
  * and/or/not? if?
    * the control structures &&, || and if are not vectorized
    * `all` and `any` are monoid functions, and are vectorized
    * `not` is a vectorized function replacing `!`?
  * structure'[i,j,k] means: [structure'i,structure'j,structure'k]
  * relations? < <= > >= (but not == !=).
    * What is vectorized ==?
      * could be: map(_==_), goes to one level, returns list of bool
      * could be: array_map(_==_), returns array of bool
* list library

2D subsystem:
* polygon -- convex_polygon as Nef polygon, intersection of half planes
  convex_polygon(vertices) -- vertices are in counterclockwise order, as this
  seems to be the standard convention.
* rotate
* scale
* align
* pack or row
* crop
  * crop(xmin=null,ymin=null,xmax=null,ymax=null)=...; // OpenSCAD style
  * crop{xmin=null,ymin=null,xmax=null,ymax=null} shape =
      intersection [shape,
        if (xmin!=null) shape2d{dist p = xmin - p.[0]},
        if (ymin!=null) shape2d{dist p = ymin - p.[1]},
        if (xmax!=null) shape2d{dist p = p.[0] - xmax},
        if (ymax!=null) shape2d{dist p = p.[1] - ymax},
      ];
* shell(n), inflate(n)
* text (steal from openjscad to begin with)
* rsquare, runion (rounded corners and fillets)
* infinite patterns
* grid (map shape onto infinite repeating shape)
* fractals
* morph(r,s1,s2)
* Escher circle limit
* minkowski sum
* Sweep. Extends a 2D object along a path.
* Extrusion. Extends the shape of a 2D object in a perpendicular direction into 3D space.
* Revolve. Sweeps a 2D object around an axis.
* Loft. Extends the contours of a shape between one or more open or closed objects.
* Slice. Divides a solid object into two separate 3D objects.


Colour:
* [r,g,b] is a colour value.
* [x,y]->[r,g,b] and [x,y,z]->[r,g,b] are 2d and 3d colour fields.
* 2D shape with color[x,y] function.
  * Either a shape has color or it doesn't. Union requires either both args
    have color, or neither.
  * When a coloured shape is transformed, the transformation is also applied
    to the colour field.
* `color(c) shape` applies a colour or a colour field to a shape.
* Colour operations:
  * predefined color values (red,orange,green,...)
  * color operations (eg, light red)
  * Geometric transforms can be applied to colour fields.
* Image import.

square:
* `Num v` is a predicate
* max[n1,n2,n3]
* abs n, abs[n1,n2]
* [x,y] - [u,v]
* [x,y] / 2
* Rename old `let` to `letrec` -- or to `where` with reversed arguments.
* Implement `let` like Scheme let. It's easier to implement in WebGL,
  and provides a nice idiom for normalizing sz in square.
* square(sz) =
    let (sz = if (Num sz) [sz,sz] else sz)
    shape2d {
      dist p = max(abs p - sz/2),
      bbox = [-sz/2, sz/2]
    };

translate:
* [x,y] - [u,v]
* translate(delta) = shape ->
    shape2d {
      dist p = shape.dist(p - delta),
      bbox = shape.bbox + delta
    };

binary union:
* min[n1,n2]
* union2(s1,s2) =
    shape2d {
      dist p = min[s1.dist p, s2.dist p],
      bbox = [min[s1.bbox.[0],s2.bbox.[0]], max[s1.bbox.[1],s2.bbox.[1]]]
    };

nary union:
* union shapes =
    shape2d {
      dist p = min [for (s = shapes) s.dist p],
      bbox = [min[for (s=shapes) s.bbox.[0]], max[for(s=shapes)s.bbox.[1]]]
    };
* GL: since shapes is a constant during inline expansion, we can expand the
  for loop into a list of expressions.
* Or implement nary union on top of binary union.
* union shapes = reduce(nothing, union2);

* curv::Shape2D is abstract, with builtin and user subclasses
  * subclass User_Defined_Shape2D, UD_Shape2D, User_Shape2D (better name?)
    Scripted_Shape2D, Exo_Shape2D also ecto- ext-
* shape2d accepts a record or module argument.
* make it zoom/rotate with mouse.
* make same code run in an OpenGL window created using C++.
  http://www.opengl-tutorial.org/beginners-tutorials/tutorial-1-opening-a-window/
* Should `shape2d` be polymorphic? Detects if shape is 2d or 3d based on bbox.
* Should `everything` and `nothing` be polymorphic? Has 2 dist functions,
  2 bboxes, for 2d and 3d cases.
  * Are there any other use cases for this?
    * How about volumetric textures like marble.
      Maybe these are colours, not shapes.
  * I could also use `everything2d` and `everything3d`.
  * Don't do this until there is a strong use case for it.
  * If `nothing` isn't polymorphic, what does `union[]` return?

# 0.1: Minimum Viable Language
* echo:
  * $ substitutions in string literals
  * echo argument is a single string
* more debug actions:
  * assert(condition) <=> if (!condition) error("assertion failed")
  * require(predicate) expr <=> let(tmp=expr)(assert(p tmp);tmp)
  * (x : predicate) -> body
  * error(string)
  * warning(string)
  * echo_timing(string,expr_value_discarded)
  * echo_timing(string) expr_value_returned
  * enter_debugger, aka `break`, `debug`
* len(module), module.[i]
* floor, ceil
* Introduce submodules (with recursive functions)
* recursive let
* records: defined r.id, merge[r1,r2]
  I don't want `merge` to accept modules as arguments: overriding an existing
  module field doesn't work if the module also contains functions closed over
  those fields.
* num: min[x,y], max[x,y], abs(x), sin(x), cos(x)

# refactoring
* value1==value2 performs a bitwise comparison (for performance),
  to speed up code like val==true and val==missing.
  The general (expensive) equality is val1.equals(val2)

# command line arguments
* command line export to different file formats (-o option)
  curv [-i node] [-o format] [-D definition] filename
  Evaluate filename as a Curv script file, yielding a module.
  Write the module elements to stdout, unless -i name is specified, then
  evaluate 'name' in the context of that module to get a value which is to
  be output.
  By default, the output format is to output each value as a Curv expression,
  terminated by a newline, unless a different format is specified by -o.
  Output formats: json, shadertoy.
  The -D flag takes a legal Curv definition as an argument.
  This definition is added to the module being read, overriding an
  existing top level definition. This override happens during parsing.
* command line documentation
  * docs/curv.1.md is converted to curv.1 by pandoc and installed
  * curv --help
  * curv --version


VM:
* debugger entry on exception
  * System::error(const Exception&) -- throw an exception, but first, enter
    the debugger.
  * debugger: commands are bound as Curv metafunctions.
    * `trace` print stack trace (with numbered call frames)
    * `frame N` specify call frame
    * inspect variables at current frame
      * local and nonlocal symbol table pointers in Frame
    * `exit`
* interrupt

OpenSCADbis proposal

# Simpler, More General Grammar
* refactor/cleanup
  * get rid of List_Sequence_Expr
* Convert `let` and `for` into metafunctions.
  If this causes pain, change/regularize the grammar.
* Simple, yaccable grammar with no conflicts or precedence declarations.
* each <list> generator
  1. `each` is a builtin metafunction. Use a subclass of `Builtin`.
  2. `each` is a builtin generator function, so `each` is a value.
     Extend `Function` with a generate callback and add Call_Expr::generate().
  3. each(v) = for (i = v) i; Not hard: just add Call_Expr::generate().
* names: Phrase or Syntax?

Generalized Definitions:
* A definition may bind multiple names.
* A Definition is compiled into an initialization Action that stores a value
  in a run-time data structure for each name that it binds (modulo constants?).
  * module (recursive scope): A definition may bind multiple names. Each such
    name has a slot containing the same Action thunk, which when evaluated
    updates all of the slots with their values.
  * qualified expr (sequential scope): each definition is compiled into an
    action that evaluates definientia and stores values in binding slots.
    At run time, execute the actions in order, then evaluate the expr.
  * record (no scope): compile definitions into actions, execute actions to
    initialize the record value. Records don't use slots, so we need a variant
    action type for updating record fields?
  * Definition::analyze(env) returns an action.
* `[x,y]=...` using above framework
* Extend `let` to support recursive functions.
* `expr where (defs)`, higher precedence than `let`, same semantics.
* (def1; def2; phrase) qualified expressions, sequentially scoped, see Loop.md
  * Each def compiles into an action which stores values in slots.
    Actions are executed in sequence, then expr is evaluated.
* generalized phrases
  * ( definition )
  * ( action; definition )
  * ( definition; phrase )
  * (def1, def2) is a compound definition that is order independent:
    (def2,def1) has the same meaning. The scoping rules depend on context.
    This meaning arises in let(def)phrase, {def}.
  * In a comma phrase, definitions and operations cannot be mixed.
    (def1,def2) is unordered, (op1,op2) is ordered.
    * It's better if we have a clear distinction between `,` and `;`.
      It's confusing if they overlap. Which they certainly do in module scope.
    * In a comma phrase, can a definition be mixed with an operation?
      Maybe no? (def1,def2) is unordered, (op1,op2) is ordered.
    * (action1 , action2) is an action, not a generator --
      semantically consistent, but not important, and potentially confusing:
      stylistically you should use `;` if a compound action
      (as opposed to a compound generator) is required.
    * If Action <: Definition then (act,def) makes sense. But this complicates
      the semantics (ordered vs unordered) and there's no utility.

Other:
* Interactive curv: special variable `_` is last value. _1,_2, or $1,$2 ...
* Introduce submodules (with recursive functions)
* Shared constructor is protected. share<T>(T&) aborts if use_count==0.
* Dynamically pluggable system abstraction. `System` class with system.echo(),
  system.warning(), system.error(), system.open(), system.namespace, etc.
  System object is refcounted, available during compile and run time.
  * Scanner::system_
  * Environ::system_. Just a single Environ object for the entire analysis
    phase, which points to a chain of Scope objects.
  * builtin_namespace(system) is a function that injects the system object into
    certain builtin functions, like `file`, avoids the cost of making system
    generally available in all evaluation contexts.
  * Do we need the system object to be a VM register? Maybe needed if
    system.error(Exception) is used to throw errors (so that debugger can be
    triggered on error). So then:
    * thread local variable
    * store in Frame--more efficient than passing as argument to eval()
      and Function::function_().
* interrupt.
  * Periodically test a thread local variable known to the curv core,
    curv::interrupt_requested. Throw an exception on interrupt, or call a System
    function to do this. I don't like thread local variables for stylistic
    reasons, but it seems legit to use one for IPC.
  * Periodically test the variable System::interrupt_requested.
    This is an extra pointer indirection more expensive than a thread-local var.
  * Periodically call a System function. Inside this function provided by
    the client is `if(thread_local_interrupt!=0)throw Interrupt()`.
    This keeps the core "pure" (free of thread-local variables) at the cost
    of a virtual function call at frequent intervals. The client will define
    the thread-local variable instead.
* still need this?
  - Environ must contain a Frame and a System. How?
    - Every Environ contains a copy of the Frame and System pointers.
    - A single mutable Environ object for the entire analysis phase,
      which points to a stack of Scope objects.
      Use RAII (in Scope class) to push/pop scopes.
      So Scope contains a reference to Environ.
      Environ::lookup calls Scope::lookup.
      More complex, but a cleaner data model, since it doesn't make it look
      like each Scope has an independent choice of Frame and System.
* refactor File_Script
  * Provide better exception messages using strerror(errno).
  * Possibly use mmap?
  * I only support UTF-8. The curv tool only runs on Windows if you use pure
    ASCII or explicitly initialize your console using `chcp 65001`.

# CURV0 (expressions):
* bug: (-1)^-0.5 error message needs parens around '-1'
* simplify this code (narrowing a Value):
  > auto value = eval(*expr);
  > assert(value.is_ref());
  > Ref_Value& ref{value.get_ref_unsafe()};
  > Module& module{dynamic_cast<Module&>(ref)};
  > return Shared<Module>(&module);
* x^y: right associative, -x^y==-(x^y), x^-y==x^(-y)
  **: algolw, Python, Rexx, Simula, Cobol, Ruby, Tcl
  ^^: D
  ^: Eiffel, Icon, Mathematica, Maple, Matlab, Basic, Awk, Bc, Lua, Julia, R
* double-conversion based strtod
* lexer parses C++14 preprocessor numerals, Numeral::analyse parses legal
  numeral while building a buffer for strtod.
* num: min[x,y], max[x,y], abs(x), sin(x), cos(x)
* string: $$ $" $id ${id} $(id) $+EE interpolation, strcat[s1,s2]
  scanner has in-string flag, parser resets/sets flag during $(expr).
* string: str@i, len(str) -- either ASCII-only, or proper Unicode
* records: defined r.id, merge[r1,r2]
* broader unit testing
* smart pointers, see docs/Shared_Ptr.md

# CURV1 (scripts, LLVM)
* pattern matching: hypot[x,y] = sqrt(x^2+y^2).
* LLVM based evaluator. Compile Meaning to LLVM IR.
  Embed raw function pointers and Values in IR as bit patterns.
* Benchmarks

# CURV2 (nested scopes)
* curried functions `dist(req)(pt) = ...;` or function literals
* script literals. At least {dist=..,bbox=..}
* printing a function? currently, <function>, even for builtins

# CURV3 (simple geometry)
* F-Rep: cube, sphere, affine transforms, boolean CSG
* implement 3d primitives in Curv using shape3d. (also is_shape)
  * this means: I'm implementing language features I need for defining geometry
* preview using ray marching--convert CSG tree to GLSL

# CURV4 (geometry export)
* use dual contouring instead of marching cubes for STL export
* does OpenCL speed this up?
* SVX export?

# Ongoing:
* more unit tests
* language reference manual

---------------------------------------------------------------------------
# Later:
* Digit separator ' in numerals (like C++14).
* Support ' in identifiers (like Haskell).
* Support `foo` quoted identifiers.
  Compatibility with OpenSCAD identifiers, GUI interfaces that display
  parameter names as GUI labels, JSON object keys.
* Rewrite scanner in re2c. Then add UTF-8 support.
* Parser: consider Boost::Spirit (recursive descent) or Lemon (similar to
  Bison, thread safe, LALR(1)), or Bison with %pure-parser (thread safe).
  Is Lemon better than Bison? Lemon:
  * the tokenizer calls the parser (instead of vice versa)
  * terminals/non-terminals don't need to be declared. Terminal name has
    initial uppercase letter.
  * productions are less error prone. Instead of $1, $2 (requires counting),
    expr(A) ::= expr(B) PLUS expr(C). { A = B + C; }
  * no mid-actions, one action per rule.
  * no repetitions and optionals.
  * small footprint: small code with no dependencies
* localization
* curv::String refactor
  * String_Builder is rewritten to use a curv::String as the internal buffer
  * User defined string literal constructs a Shared<String>:
    underlying object is constructed at compile time with no mallocs,
    and without two copies of the string literal data.
* dtostr() refactor
  * put all 4 parameters into a DStyle struct.
* aux::Exception/curv::String refactor. Aux shouldn't depend on Curv.
  Original plan: to put String in Aux. But we'll see how Curv runtime evolves.

build system?
* Fast. Correct: auto track dependencies, rebuild on recipe change,
  delete stale objects. High level: standard abstractions that are portable
  across linux/osX/win. Cross project dependency discovery and configuration
  (see pkg-config). Packageable: libcurv can be packaged for Ubuntu; build tools
  are already in ubuntu repo.
* Should I use pkg-config for build-time dependency discovery and configuration?
  Do I install a *.pc file that records compiler and linker flags required to
  use the curv library? Can I build an Ubuntu package for libcurv?
* Google Bazel is fast, correct and high level. Still in beta. Missing some
  platform support, cross project dependencies. Wait for 1.0 in 2017.
* cmake is popular and well supported on multiple platforms.
  It has comprehensive portability abstractions.
  It is more correct than expected, given that it generates makefiles.
  Rebuilds on recipe change, tracks header dependencies. Doesn't delete stale
  products. (Has an experimental option to generate ninja files.)
* ninja is fast. It rebuilds if recipe changes. Header dependencies depend
  on the gcc feature to output dependencies (suboptimal, I'd rather it monitor
  which files are opened by build tools).
  Need a generator: ninja+cmake, ninja+gen, ninja+bash, ...
* tup is fast and correct. Tup determines hdr file dependencies automagically.
  Tup rebuilds if recipe has changed. Tup deletes build products that can
  no longer be generated. Tup has a high level command language (Lua).
  * Tup is not in the Ubuntu package universe. There are PPAs...
    Building from source isn't working...
  * Tup is deeply magical and edgy. It uses FUSE, performs kernel magic to
    overlay source and object directories, and makes tools confused
    about what their current directory actually is, causing some things to
    break. This can be overcome using the ^c chroot flag, which requires
    setuid root. FUSE probably no longer works in MacOS ElCapitan due to SIP.
  * So edgy it might discourage contributors. The automagic dependency tracking
    requires deep magic that is also flaky: fuse, chroot, dynamic lib injection.
    Eg, the ConEmu terminal emulator breaks DLL injection on Windows.
    Tup is reported to not work on FreeBSD (fuse works differently).
* redo. Simple, powerful, elegant. Also slow (as fast or slower than make).
* So, probably cmake+ninja.
