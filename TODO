Bool_Array : vectorized boolean operators
- vectorize `!a`
* `and`, `or` and `xor` are vectorized boolean monoids.
* <, <=, >, >= work elementwise on arrays.
* `are_equal(a,b)`: elementwise variant of a==b
* `are_unequal(a,b)`: elementwise variant of a!=b.
  Elements are scalars (non-list values).
  Equivalent to xor(a,b) when applied to boolean arrays.
* `select`: vectorized version of `if`
* vectorize `bit`. Maybe `bit b = select(b, 1, 0)`.
* SubCurv supports bool[2-4] and vectorized boolean ops
* unit tests for operations on reactive values

Bool32: ops on boolean vectors of size 32 -- for noise library
* All of the Bool_Array ops, plus the `Bool32` module.
* SubCurv supports bool32 type (represented as `unsigned`).

Libcurv builtins API
* Too much boilerplate to write this kind of code.
* Do more experiments with C++ before abandoning C++ for another language.
* Can builtins be implemented in Curv?
* The `and` project. What's the shortest, simplest implementation?
  * Implement "full boilerplate" version in C++.
  * Add bool[2-4] to SubCurv.
  * Add bool32 to SubCurv.
  * Now simplify and generalize the code.
    * Create a generalized `monoid` constructor.
      A macro call expands to a template call expands to a class.

Fix colour rendering (needs Bool_Array)
---------------------------------------
* colour_picker: convert between sRGB in the uniform variable,
  and linear RGB in the Curv parameter.
* Use mathematically correct conversion between linRGB and sRGB.
* fragment shader outputs linear RGB, OpenGL converts to sRGB in hardware.
  https://stackoverflow.com/questions/56204242/do-i-need-output-gamma-correction-in-a-fragment-shader
  glEnable(GL_FRAMEBUFFER_SRGB);
  https://www.khronos.org/opengl/wiki/Framebuffer#Colorspace

// from Blender (GLSL)
float linearrgb_to_srgb(float c)
{
  if (c < 0.0031308) {
    return (c < 0.0) ? 0.0 : c * 12.92;
  }
  else {
    return 1.055 * pow(c, 1.0 / 2.4) - 0.055;
  }
}

//// stack exchange:
float sRGB(float x) {
    if (x <= 0.00031308)
        return 12.92 * x;
    else
        return 1.055*pow(x,(1.0 / 2.4) ) - 0.055;
}
vec3 sRGB_v3(vec3 c) {
    return vec3(sRGB(c.x),sRGB(c.y),sRGB(c.z));
}

//// stack exchange:
// Converts a color from linear light gamma to sRGB gamma
vec4 fromLinear(vec4 linearRGB)
{
    bvec4 cutoff = lessThan(linearRGB, vec4(0.0031308));
    vec4 higher = vec4(1.055)*pow(linearRGB, vec4(1.0/2.4)) - vec4(0.055);
    vec4 lower = linearRGB * vec4(12.92);

    return mix(higher, lower, cutoff);
}
// Converts a color from sRGB gamma to linear light gamma
vec4 toLinear(vec4 sRGB)
{
    bvec4 cutoff = lessThan(sRGB, vec4(0.04045));
    vec4 higher = pow((sRGB + vec4(0.055))/vec4(1.055), vec4(2.4));
    vec4 lower = sRGB/vec4(12.92);

    return mix(higher, lower, cutoff);
}

lessThan: all versions of GLSL
mix with bvec4 3rd argument: GLSL 4.5
