Fix problem with union seams, caused by mesh exporter.
Support additional meshers with sharp edge handling.
Libfive seems to fix the union seam problem. Remaining libfive issues:
* -Omgen=#smooth|#sharp
    #smooth is the OpenVDB mesher, guarantees valid topology, rounds edges
    #sharp is the DC mesher, detects edges, may generate bad meshes
* Libfive multithreaded rendering is broken (so I disable it for now)
  * Report a libfive bug with test case.
* MacOS build is broken
  * I've reported a libfive bug, Matt suggested a reasonable fix to his code.
* #sharp mesher creates artifacts in shreks_donut. I believe that `bend` and
  `twist` create "bent" or "twisted" distance fields where gradients are not
  surface normals, and this breaks DC. Add a 'rectify' option that uses
  Newton's method to construct normals.
* Bug report in libfive: Scale dependent rendering of a cube.
* Support additional libfive meshing parameters? These have a low value.
  * `max_err` controls cell merging & quality. default is high quality.
  * `workers` controls parallelism (broken right now).
  * `alg` is dual_contouring, iso_simplex or hybrid. Default is DC.

More meshing:
* Add SVG export of 2D models
* -Ores: A single resolution parameter controls VDB, DC 3d and DC 2d SVG export.
  Replaces `vsize`, since SVG doesn't have voxels.
  Could also use `res` to control PNG export.
* Extract #smooth mesher from openvdb, eliminate that dependency.
  * simplify builds on all platforms.
  * create a standalone `curv.exe` on Windows.
* Add #fractal mesher: create voxel grid, low pass filter, then use #smooth.
  True fractals have no surface normals, so #sharp doesn't make sense.
* Add colour 3D mandelbulb or the like and print it.

Shape metadata:
* Goal: to put meshing parameters in a shape.
* optional `meta` shape field. Ignored by shape combinators.
  Contains render and mesh export configuration. Overrides config file.
  Overrides command line, just like existing `render` field.
* `shape >> set_meta {...}`
* `make_shape {..., meta: {...}}`
* The config file has a tree structured namespace: `viewer` & `export` trees.
  This allows you to specify export.aa=4 for PNG export but not for viewing.
  Metadata should have the same namespace.

Document 'term' phrases. Tight and loose formatting style.
In Records doc, call out 'R.a' vs 'R .a' style of field selection.

Clean up documentation
* remove or fix anything from docs directory that is old or out of date.
* make sure everything in the version 0.5 release notes is documented.

make_shape documentation:
* the fields of a shape value
* The t in [x,y,z,t] means the time in seconds since the beginning of the animation. This lets you create animated shapes.
* Distance functions are written in a staticallly typed, restricted subset of Curv which is called "SubCurv". Unfortunately, curried functions like quadratic p0 p1 p2 w0 w1 w2 t are not yet supported in SubCurv. You must instead use quadratic [p0, p1, p2, w0, w1, w2, t]: use a single argument that is a list.

Tutorials:
* translating GLSL into Curv
* fillets and rounds
* blob & skeleton based modelling
* strokes & sweeps

transliterating GLSL into Curv -- docs/language/GLSL_to_Curv.rst
   float x = 1.0;   =>    local x = 1;
   x = x + 1;       =>    x := x + 1;
   v.x  =>   v.[X]
   v.xy =>  v.[[X,Y]]
   dot(v1,v2)  =>  dot[v1,v2]
   vec(x,y)  =>  [x,y]

Arrow values: `a: b` and `#a => b`. Used for variants and record fields.

---------
* auto detection of c++ compiler for '-O jit' default value

Finish imperative:
* document local
* unit tests
* Imperative.rst

Finish boolean arrays:
* SubCurv: unit tests for 3 cases of and/or
* general arrays of bool and bool32
* fix TODOs in array_op.h
* binary boolean op: mixed bool/bool32 operations

Primitives API:
* The Context describes the call syntax: 'f x', '-x', 'x `f` y', 'x + y'.
  A more specific argument Location is extracted from the syntax when throwing
  an exception concerning a bad argument.
* Can builtins be implemented in Curv?
* Will a macro simplify the definition of And_Prim?
* define Operation classes using Prim?

Bool_Array : vectorized boolean operators
* <, <=, >, >= work elementwise on arrays.
* `are_equal(a,b)`: elementwise variant of a==b
* `are_unequal(a,b)`: elementwise variant of a!=b.
  Elements are scalars (non-list values).
  Equivalent to xor(a,b) when applied to boolean arrays.
* `select`: vectorized version of `if`
* Maybe define `bit b = select(b, 1, 0)`.
* SubCurv supports bool[2-4] and vectorized boolean ops
* unit tests for operations on reactive values
  * Right now, reactive values are only generated when compiling a parametric
    shape to GLSL. I could create a builtin implementing the same logic.
    * Take a parametric record as argument, compile the parameters to reactive
      values, then call the record's main() function.
    * A builtin that compiles a Curv value into machine code via C++.
      Special handling for parametric records which tests reactive values.
