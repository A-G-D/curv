Fix problem with union seams, caused by mesh exporter.
Support additional meshers with sharp edge handling.
Libfive seems to fix the union seam problem. Remaining libfive issues:
* MacOS build is broken
  * I've reported a libfive bug, waiting for response.
* Libfive multithreaded rendering is broken (so I disable it for now)
  * Report a libfive bug with test case.
* Add SVG export of 2D models
* -Ores: A single resolution parameter controls VDB, DC 3d and DC 2d SVG export.
  Replaces `vsize`, since SVG doesn't have voxels.
  Could also use `res` to control PNG export.
* -Omstyle=#smooth|#cad|#fractal, replaces -Omgen.
    #smooth is the OpenVDB mesher, guarantees valid topology, rounds edges
    #cad is the DC mesher, detects edges, may generate bad meshes
    #fractal creates a voxel grid, low pass filter, then use #smooth mesher
  Default is #cad.
* replace magic numbers with scale-independent expressions
  * epsilon
* Support additional libfive meshing parameters? These have a low value.
  * `max_err` controls cell merging & quality. default is high quality.
  * `workers` controls parallelism (broken right now).
  * `alg` is dual_contouring, iso_simplex or hybrid. Default is DC.

More meshing:
* Extract #smooth mesher from openvdb, eliminate that dependency.
  * simplify builds on all platforms.
  * create a standalone `curv.exe` on Windows.
* Add #fractal mesher.
* Add colour 3D mandelbulb or the like and print it.

Clean up documentation
* remove or fix anything from docs directory that is old or out of date.
* make sure everything in the version 0.5 release notes is documented.

make_shape documentation:
* the fields of a shape value
* The t in [x,y,z,t] means the time in seconds since the beginning of the animation. This lets you create animated shapes.
* Distance functions are written in a staticallly typed, restricted subset of Curv which is called "SubCurv". Unfortunately, curried functions like quadratic p0 p1 p2 w0 w1 w2 t are not yet supported in SubCurv. You must instead use quadratic [p0, p1, p2, w0, w1, w2, t]: use a single argument that is a list.

Tutorials:
* translating GLSL into Curv
* fillets and rounds
* blob & skeleton based modelling
* strokes & sweeps

transliterating GLSL into Curv -- docs/language/GLSL_to_Curv.rst
   float x = 1.0;   =>    local x = 1;
   x = x + 1;       =>    x := x + 1;
   v.x  =>   v.[X]
   v.xy =>  v.[[X,Y]]
   dot(v1,v2)  =>  dot[v1,v2]
   vec(x,y)  =>  [x,y]

---------
* auto detection of c++ compiler for '-O jit' default value

Finish imperative:
* document local
* unit tests
* Imperative.rst

Finish boolean arrays:
* SubCurv: unit tests for 3 cases of and/or
* general arrays of bool and bool32
* fix TODOs in array_op.h
* binary boolean op: mixed bool/bool32 operations

Primitives API:
* The Context describes the call syntax: 'f x', '-x', 'x `f` y', 'x + y'.
  A more specific argument Location is extracted from the syntax when throwing
  an exception concerning a bad argument.
* Can builtins be implemented in Curv?
* Will a macro simplify the definition of And_Prim?
* define Operation classes using Prim?

Bool_Array : vectorized boolean operators
* <, <=, >, >= work elementwise on arrays.
* `are_equal(a,b)`: elementwise variant of a==b
* `are_unequal(a,b)`: elementwise variant of a!=b.
  Elements are scalars (non-list values).
  Equivalent to xor(a,b) when applied to boolean arrays.
* `select`: vectorized version of `if`
* Maybe define `bit b = select(b, 1, 0)`.
* SubCurv supports bool[2-4] and vectorized boolean ops
* unit tests for operations on reactive values
  * Right now, reactive values are only generated when compiling a parametric
    shape to GLSL. I could create a builtin implementing the same logic.
    * Take a parametric record as argument, compile the parameters to reactive
      values, then call the record's main() function.
    * A builtin that compiles a Curv value into machine code via C++.
      Special handling for parametric records which tests reactive values.
