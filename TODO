Bool_Array : vectorized boolean operators
- vectorize `!a`
* `all` and `any` are vectorized boolean monoids for && and ||.
* <, <=, >, >= work elementwise on arrays.
* `are_equal(a,b)`: elementwise variant of a==b
* `select`: vectorized version of `if`
* vectorize `bit`
* SubCurv supports bvec[2-4] and vectorized boolean ops
* unit tests for operations on reactive values

Fix colour rendering (needs Bool_Array)
---------------------------------------
* colour_picker: convert between sRGB in the uniform variable,
  and linear RGB in the Curv parameter.
* Use mathematically correct conversion between linRGB and sRGB.
* fragment shader outputs linear RGB, OpenGL converts to sRGB in hardware.
  https://stackoverflow.com/questions/56204242/do-i-need-output-gamma-correction-in-a-fragment-shader
  glEnable(GL_FRAMEBUFFER_SRGB);
  https://www.khronos.org/opengl/wiki/Framebuffer#Colorspace

// from Blender (GLSL)
float linearrgb_to_srgb(float c)
{
  if (c < 0.0031308) {
    return (c < 0.0) ? 0.0 : c * 12.92;
  }
  else {
    return 1.055 * pow(c, 1.0 / 2.4) - 0.055;
  }
}

//// stack exchange:
float sRGB(float x) {
    if (x <= 0.00031308)
        return 12.92 * x;
    else
        return 1.055*pow(x,(1.0 / 2.4) ) - 0.055;
}
vec3 sRGB_v3(vec3 c) {
    return vec3(sRGB(c.x),sRGB(c.y),sRGB(c.z));
}

//// stack exchange:
// Converts a color from linear light gamma to sRGB gamma
vec4 fromLinear(vec4 linearRGB)
{
    bvec4 cutoff = lessThan(linearRGB, vec4(0.0031308));
    vec4 higher = vec4(1.055)*pow(linearRGB, vec4(1.0/2.4)) - vec4(0.055);
    vec4 lower = linearRGB * vec4(12.92);

    return mix(higher, lower, cutoff);
}
// Converts a color from sRGB gamma to linear light gamma
vec4 toLinear(vec4 sRGB)
{
    bvec4 cutoff = lessThan(sRGB, vec4(0.04045));
    vec4 higher = pow((sRGB + vec4(0.055))/vec4(1.055), vec4(2.4));
    vec4 lower = sRGB/vec4(12.92);

    return mix(higher, lower, cutoff);
}

lessThan: all versions of GLSL
mix with bvec4 3rd argument: GLSL 4.5
