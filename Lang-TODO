echo, assert, warning, error are ignored in GL.

String:
* $id interpolation
* $+EE or $[0xEE] interpolation

Libraries.
* use(file "pathname.curv") -- arg evaluated as const expr in builtin namespace,
  file must evaluate to a module.
* `lib` is a struct for accessing library files in /usr/local/lib/curv.
  `lib.foo` loads /usr/local/lib/curv/foo.curv.
  * `use(lib.foo)`
* modules: _foo is not exported, is omitted from the public dictionary.
  curv::Module has a public dictionary and a debug dictionary.
  _foo is private in std.curv, and in all other *.curv files.

Misc.
* remove a'b ?
* GL: && || if use lazy evaluation

Patterns (Bindings and Lambda):
* action thunks, instead of value thunks.
* (x,y) = f(a);
* {x,y}=... is pattern matching on a record. Extra fields on right -> error.
* Record patterns can be used as function parameters.
* Default values in record patterns, `{x=0,y=1} = ...`
* functions with refutable parameter patterns lead to:
  switch((x,y,z)->..., a->...) -- returns a function
* see also Parameter Preconditions

Slice notation:
* Extend vector swizzling, like v[X,Y,Z], with assignment, like v[X,Y,Z] = v2,
  for GLSL compatibility. Source and destination lists have the same count.
* a[i..j]. a[i..j] := list. In a range slice assignment,
  source and destination lists can have different counts.
* Generalized list slice notation, supporting full list constructor notation,
  with assignment?
* Maybe a[..j] and a[i..] as special shortcuts, in this context?
* Can't support Python negative indexes (-1 indexes the last element)
  because [0..count a - 1] is a list of the indexes of a, even if a is empty,
  meaning that [0..-1] denotes []. Maybe I'd need to use separate syntax
  for slices and ranges, as Python does.
* Generalized multidimensional array slicing?

Vectorized boolean operations:
* vectorize `bit`
* Vectorized relations are:
  * <' <=' >' >=' ==' !='
  * .< .<= .> .>= .== .!= (Julia)
  * less, greater, equal, less_or_equal, greater_or_equal, not_equal
  * less, greater, equal, not_less, not_greater, not_equal
* `not` is vectorized version of `!`.
* `all` and `any` are vectorized boolean monoids for && and ||.
  * Name is consistent with GLSL,R,Julia,Python,Matlab.
  * Use some(pred)list, every(pred)list, name consistent with Javascript.
* ifelse(cond,thenval,elseval)
* Rationale: vectorized boolean ops have different names than unvectorized ones.
  * x==y compares vectors and returns bool, unlike xs=='ys.
  * a&&b short circuits if a==false, but all(a,b) must evaluate b if a==false
    to implement broadcasting.
  * ifelse(b,c,a) must evaluate all 3 arguments if b is an array.
  * The unvectorized relations are guaranteed to return Bool, or fail,
    which is appropriate for the most common use case, which is to construct
    an argument for if, &&, ||, which require a Bool argument.
* Many languages represent boolean values as the numbers 0 and 1.
  In an array language, an array of booleans represented as 0 and 1
  is a useful representation, you can do arithmetic on it.
  In Curv, booleans are not numbers, but you can convert between the two
  representations using vectorized operations. Eg,
  * enbool(i) = [false,true]'i;
  * debool(b) = ifelse(b, 1, 0);
  Or:
  * tobool(i), frombool(b)
  Or:
  * idiom: i != 0, or i !=' 0
  * bit(b) = ifelse(b, 1, 0);

Design by contract:
* postconditions:
  ensure pred val = do assert(pred val) in val;
  sort x =
    ensure sorted <<
    <body of sort function>;
* parameter preconditions:
  * (predicate x) -> body
  * (x isa Constructor) -> body
  * (x >= 0) -> body

Debug actions:
* echo_timing(string,expr), returns value of expr
  * Might want to measure eval time while ignoring result:
    * Assign value to a variable, don't use variable.
    * `ignore(arg)` is an action that evaluates and ignores arg.
* `enter_debugger`, aka `debug`

Generalized Definitions:
* id = expr
* ( definition )
* def1; def2; def3
* `[x,y,z] = expr` and other patterns
* `if (cond) (a=foo;b=bar) else (a=bar;b=foo)`
* expr where (defs)

Lexical:
* unicode operators (needs re2c)
* Digit separator in numerals: ' like C++14, or _
* Support ' in identifiers (like Haskell).
* Support `foo` quoted identifiers.
  Compatibility with GUI interfaces that display
  parameter names as GUI labels, JSON object keys.

OpenSCAD2 prototype oriented programming?
* Model parameters and shape are bundled into one value.
* Simple syntax for customizing a subset of model parameters, generating
  a new shape.
* The BOM feature: can extract model parameters from a model script,
  generate JSON output.
* Language support for using a GUI to tweak model parameters?
* CSG trees: output a CSG tree as JSON, read a CSG tree to reconstruct model.
  Shapes contain the name of their constructor, and their constructor
  arguments. (Implemented using a proposed 'constructor' feature.)
